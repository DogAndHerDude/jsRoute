{"version":"0.2.8","files":{"/Users/kris/q-io/spec/fs/boot-directory-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":44,"total":44,"coverage":{},"source":"var FS = require(\"../../fs-boot\");\n\nvar specs = [\n    {\n        \"from\": \"foo\",\n        \"to\": \"\"\n    },\n    {\n        \"from\": \"\",\n        \"to\": \"..\"\n    },\n    {\n        \"from\": \".\",\n        \"to\": \"..\"\n    },\n    {\n        \"from\": \"..\",\n        \"to\": \"../..\"\n    },\n    {\n        \"from\": \"../foo\",\n        \"to\": \"..\"\n    },\n    {\n        \"from\": \"/foo/bar\",\n        \"to\": \"/foo\"\n    },\n    {\n        \"from\": \"/foo\",\n        \"to\": \"/\"\n    },\n    {\n        \"from\": \"/\",\n        \"to\": \"/\"\n    }\n];\n\ndescribe(\"fs-boot directory\", function () {\n    specs.forEach(function (spec) {\n        it(\"should parse \" + JSON.stringify(spec.from), function () {\n            expect(FS.directory(spec.from)).toBe(spec.to);\n        });\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"1b02b3ee233638627b6bb0767be78887"},"/Users/kris/q-io/fs-boot.js":{"stats":{"percentage":0.8664495114006515,"lines":[{"lineno":19},{"lineno":44},{"lineno":82},{"lineno":119},{"lineno":120},{"lineno":121},{"lineno":122},{"lineno":123},{"lineno":124},{"lineno":125},{"lineno":127},{"lineno":128},{"lineno":129},{"lineno":130},{"lineno":131},{"lineno":133},{"lineno":134},{"lineno":135},{"lineno":136},{"lineno":138},{"lineno":139},{"lineno":140},{"lineno":141},{"lineno":143},{"lineno":147},{"lineno":151},{"lineno":155},{"lineno":156},{"lineno":157},{"lineno":237},{"lineno":248},{"lineno":249},{"lineno":250},{"lineno":251},{"lineno":289},{"lineno":290},{"lineno":301},{"lineno":302},{"lineno":303},{"lineno":304},{"lineno":307}],"missing":41,"seen":266,"total":307,"coverage":{"19":{"partial":false,"source":"    return str.replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\");","missing":[{"startCol":4,"endCol":59},{"startCol":11,"endCol":58}]},"44":{"partial":false,"source":"    exports.ALT_SEPARATOR = \"/\";","missing":[{"startCol":4,"endCol":32}]},"82":{"partial":false,"source":"        throw new Error(\"Cannot split \" + (typeof path) + \", \" + JSON.stringify(path));","missing":[{"startCol":8,"endCol":87},{"startCol":24,"endCol":55},{"startCol":65,"endCol":85}]},"119":{"partial":false,"source":"    var root = \"\";","missing":[{"startCol":4,"endCol":18}]},"120":{"partial":false,"source":"    var parents = [];","missing":[{"startCol":4,"endCol":21}]},"121":{"partial":false,"source":"    var children = [];","missing":[{"startCol":4,"endCol":22}]},"122":{"partial":false,"source":"    var leaf = \"\";","missing":[{"startCol":4,"endCol":18}]},"123":{"partial":false,"source":"    for (var i = 0; i < arguments.length; i++) {","missing":[{"startCol":20,"endCol":40},{"startCol":42,"endCol":45}]},"124":{"partial":false,"source":"        var path = String(arguments[i]);","missing":[{"startCol":8,"endCol":40},{"startCol":19,"endCol":39}]},"125":{"partial":false,"source":"        if (path == \"\")","missing":[{"startCol":12,"endCol":22}]},"127":{"partial":false,"source":"        var parts = path.split(exports.SEPARATORS_RE());","missing":[{"startCol":8,"endCol":56},{"startCol":20,"endCol":55},{"startCol":31,"endCol":54}]},"128":{"partial":false,"source":"        if (exports.isAbsolute(path)) {","missing":[{"startCol":12,"endCol":36}]},"129":{"partial":false,"source":"            root = parts.shift() + exports.SEPARATOR;","missing":[{"startCol":12,"endCol":53},{"startCol":19,"endCol":32}]},"130":{"partial":false,"source":"            parents = [];","missing":[{"startCol":12,"endCol":25}]},"131":{"partial":false,"source":"            children = [];","missing":[{"startCol":12,"endCol":26}]},"133":{"partial":false,"source":"        leaf = parts.pop();","missing":[{"startCol":8,"endCol":27},{"startCol":15,"endCol":26}]},"134":{"partial":false,"source":"        if (leaf == \".\" || leaf == \"..\") {","missing":[{"startCol":12,"endCol":23},{"startCol":27,"endCol":39}]},"135":{"partial":false,"source":"            parts.push(leaf);","missing":[{"startCol":12,"endCol":28}]},"136":{"partial":false,"source":"            leaf = \"\";","missing":[{"startCol":12,"endCol":22}]},"138":{"partial":false,"source":"        for (var j = 0; j < parts.length; j++) {","missing":[{"startCol":24,"endCol":40},{"startCol":42,"endCol":45}]},"139":{"partial":false,"source":"            var part = parts[j];","missing":[{"startCol":12,"endCol":32}]},"140":{"partial":false,"source":"            if (part == \".\" || part == \"\") {","missing":[{"startCol":16,"endCol":27},{"startCol":31,"endCol":41}]},"141":{"partial":false,"source":"            } else if (part == \"..\") {","missing":[{"startCol":23,"endCol":35}]},"143":{"partial":false,"source":"                    children.pop();","missing":[{"startCol":20,"endCol":34}]},"147":{"partial":false,"source":"                        parents.push(\"..\");","missing":[{"startCol":24,"endCol":42}]},"151":{"partial":false,"source":"                children.push(part);","missing":[{"startCol":16,"endCol":35}]},"155":{"partial":false,"source":"    path = parents.concat(children).join(exports.SEPARATOR);","missing":[{"startCol":4,"endCol":60},{"startCol":11,"endCol":59},{"startCol":25,"endCol":35}]},"156":{"partial":false,"source":"    if (path) leaf = exports.SEPARATOR + leaf;","missing":[{"startCol":14,"endCol":46},{"startCol":21,"endCol":45}]},"157":{"partial":false,"source":"    return root + path + leaf;","missing":[{"startCol":4,"endCol":30},{"startCol":11,"endCol":22}]},"237":{"partial":false,"source":"        return /[a-zA-Z]:$/.test(first);","missing":[{"startCol":8,"endCol":40},{"startCol":15,"endCol":39}]},"248":{"partial":false,"source":"    if (!exports.isAbsolute(path))","missing":[{"startCol":9,"endCol":33}]},"249":{"partial":false,"source":"        path = require(\"./fs\").absolute(path);","missing":[{"startCol":8,"endCol":46},{"startCol":15,"endCol":45},{"startCol":22,"endCol":30}]},"250":{"partial":false,"source":"    var parts = exports.split(path);","missing":[{"startCol":4,"endCol":36},{"startCol":16,"endCol":35}]},"251":{"partial":false,"source":"    return exports.join(parts[0], \"\");","missing":[{"startCol":4,"endCol":38},{"startCol":11,"endCol":37}]},"289":{"partial":false,"source":"        base = base.replace(","missing":[{}]},"290":{"partial":false,"source":"            new RegExp(regExpEscape(extension) + \"$\"),","missing":[{},{"startCol":23,"endCol":52}]},"291":{"partial":false,"source":"            \"\"","missing":[{}]},"292":{"partial":false,"source":"        );","missing":[{}]},"301":{"partial":false,"source":"    path = exports.base(path);","missing":[{"startCol":4,"endCol":30},{"startCol":11,"endCol":29}]},"302":{"partial":false,"source":"    path = path.replace(/^\\.*/, \"\");","missing":[{"startCol":4,"endCol":36},{"startCol":11,"endCol":35}]},"303":{"partial":false,"source":"    var index = path.lastIndexOf(\".\");","missing":[{"startCol":4,"endCol":38},{"startCol":16,"endCol":37}]},"304":{"partial":false,"source":"    return index <= 0 ? \"\" : path.substring(index);","missing":[{"startCol":4,"endCol":51},{"startCol":11,"endCol":21},{"startCol":24,"endCol":26},{"startCol":29,"endCol":50}]},"307":{"partial":true,"source":"})(typeof exports !== \"undefined\" ? exports : FS_BOOT = {});","missing":[{"startCol":46,"endCol":58}]}},"source":"(function (exports) {\n\n// -- kriskowal Kris Kowal Copyright (C) 2009-2010 MIT License\n// -- tlrobinson Tom Robinson TODO\n\n/**\n * Pure JavaScript implementations of file system path\n * manipulation.\n */\n\n// NOTE: this file may be used is the engine bootstrapping\n// process, so any \"requires\" must be accounted for in\n// narwhal.js\n\n/*whatsupdoc*/\n/*markup markdown*/\n\nvar regExpEscape = function (str) {\n    return str.replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\");\n};\n\nvar path = require(\"path\");\n\n/**\n * @name ROOT\n * * `/` on Unix\n * * `\\` on Windows\n */\n\n/**\n * @name SEPARATOR\n * * `/` on Unix\n * * `\\` on Windows\n */\n\n/**\n * @name ALT_SEPARATOR\n * * undefined on Unix\n * * `/` on Windows\n */\n\nexports.ROOT = exports.SEPARATOR = path.sep;\nif (path.sep === \"\\\\\") {\n    exports.ALT_SEPARATOR = \"/\";\n} else {\n    exports.ALT_SEPARATOR = undefined;\n}\n\n// we need to make sure the separator regex is always in sync with the separators.\n// this caches the generated regex and rebuild if either separator changes.\nvar separatorCached, altSeparatorCached, separatorReCached;\n/**\n * @function\n */\nexports.SEPARATORS_RE = function () {\n    if (\n        separatorCached !== exports.SEPARATOR ||\n        altSeparatorCached !== exports.ALT_SEPARATOR\n    ) {\n        separatorCached = exports.SEPARATOR;\n        altSeparatorCached = exports.ALT_SEPARATOR;\n        separatorReCached = new RegExp(\"[\" +\n            (separatorCached || \"\").replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\") +\n            (altSeparatorCached || \"\").replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, \"\\\\$&\") +\n        \"]\", \"g\");\n    }\n    return separatorReCached;\n}\n\n/**\n * separates a path into components.  If the path is\n * absolute, the first path component is the root of the\n * file system, indicated by an empty string on Unix, and a\n * drive letter followed by a colon on Windows.\n * @returns {Array * String}\n */\nexports.split = function (path) {\n    var parts;\n    try {\n        parts = String(path).split(exports.SEPARATORS_RE());\n    } catch (exception) {\n        throw new Error(\"Cannot split \" + (typeof path) + \", \" + JSON.stringify(path));\n    }\n    // this special case helps isAbsolute\n    // distinguish an empty path from an absolute path\n    // \"\" -> [] NOT [\"\"]\n    if (parts.length === 1 && parts[0] === \"\")\n        return [];\n    // \"a\" -> [\"a\"]\n    // \"/a\" -> [\"\", \"a\"]\n    return parts;\n};\n\n/**\n * Takes file system paths as variadic arguments and treats\n * each as a file or directory path and returns the path\n * arrived by traversing into the those paths.  All\n * arguments except for the last must be paths to\n * directories for the result to be meaningful.\n * @returns {String} path\n */\nexports.join = function () {\n    if (arguments.length === 1 && Array.isArray(arguments[0]))\n        return exports.normal.apply(exports, arguments[0]);\n    return exports.normal.apply(exports, arguments);\n};\n\n/**\n * Takes file system paths as variadic arguments and treats\n * each path as a location, in the URL sense, resolving each\n * new location based on the previous.  For example, if the\n * first argument is the absolute path of a JSON file, and\n * the second argument is a path mentioned in that JSON\n * file, `resolve` returns the absolute path of the\n * mentioned file.\n * @returns {String} path\n */\nexports.resolve = function () {\n    var root = \"\";\n    var parents = [];\n    var children = [];\n    var leaf = \"\";\n    for (var i = 0; i < arguments.length; i++) {\n        var path = String(arguments[i]);\n        if (path == \"\")\n            continue;\n        var parts = path.split(exports.SEPARATORS_RE());\n        if (exports.isAbsolute(path)) {\n            root = parts.shift() + exports.SEPARATOR;\n            parents = [];\n            children = [];\n        }\n        leaf = parts.pop();\n        if (leaf == \".\" || leaf == \"..\") {\n            parts.push(leaf);\n            leaf = \"\";\n        }\n        for (var j = 0; j < parts.length; j++) {\n            var part = parts[j];\n            if (part == \".\" || part == \"\") {\n            } else if (part == \"..\") {\n                if (children.length) {\n                    children.pop();\n                } else {\n                    if (root) {\n                    } else {\n                        parents.push(\"..\");\n                    }\n                }\n            } else {\n                children.push(part);\n            }\n        };\n    }\n    path = parents.concat(children).join(exports.SEPARATOR);\n    if (path) leaf = exports.SEPARATOR + leaf;\n    return root + path + leaf;\n};\n\n/**\n * Takes paths as any number of arguments and reduces them\n * into a single path in normal form, removing all \".\" path\n * components, and reducing \"..\" path components by removing\n * the previous path component if possible.\n * @returns {String} path\n */\nexports.normal = function () {\n    var root = \"\";\n    var parents = [];\n    var children = [];\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n        var path = String(arguments[i]);\n        // empty paths have no affect\n        if (path === \"\")\n            continue;\n        var parts = path.split(exports.SEPARATORS_RE());\n        if (exports.isAbsolute(path)) {\n            root = parts.shift() + exports.SEPARATOR;\n            parents = [];\n            children = [];\n        }\n        for (var j = 0, jj = parts.length; j < jj; j++) {\n            var part = parts[j];\n            if (part == \".\" || part == \"\") {\n            } else if (part == \"..\") {\n                if (children.length) {\n                    children.pop();\n                } else {\n                    if (root) {\n                    } else {\n                        parents.push(\"..\");\n                    }\n                }\n            } else {\n                children.push(part);\n            }\n        }\n    }\n    path = parents.concat(children).join(exports.SEPARATOR);\n    return root + path;\n};\n\n/***\n * @returns {Boolean} whether the given path begins at the\n * root of the file system or a drive letter.\n */\nexports.isAbsolute = function (path) {\n    // for absolute paths on any operating system,\n    // the first path component always determines\n    // whether it is relative or absolute.  On Unix,\n    // it is empty, so [\"\", \"foo\"].join(\"/\") == \"/foo\",\n    // \"/foo\".split(\"/\") == [\"\", \"foo\"].\n    var parts = exports.split(path);\n    // split(\"\") == [].  \"\" is not absolute.\n    // split(\"/\") == [\"\", \"\"] is absolute.\n    // split(?) == [\"\"] does not occur.\n    if (parts.length == 0)\n        return false;\n    return exports.isRoot(parts[0]);\n};\n\n/**\n * @returns {Boolean} whether the given path does not begin\n * at the root of the file system or a drive letter.\n */\nexports.isRelative = function (path) {\n    return !exports.isAbsolute(path);\n};\n\n/**\n * @returns {Boolean} whether the given path component\n * corresponds to the root of the file system or a drive\n * letter, as applicable.\n */\nexports.isRoot = function (first) {\n    if (exports.SEPARATOR === \"\\\\\") {\n        return /[a-zA-Z]:$/.test(first);\n    } else {\n        return first == \"\";\n    }\n};\n\n/**\n * @returns {String} the Unix root path or corresponding\n * Windows drive for a given path.\n */\nexports.root = function (path) {\n    if (!exports.isAbsolute(path))\n        path = require(\"./fs\").absolute(path);\n    var parts = exports.split(path);\n    return exports.join(parts[0], \"\");\n};\n\n/**\n * @returns {String} the parent directory of the given path.\n */\nexports.directory = function (path) {\n    path = exports.normal(path);\n    var absolute = exports.isAbsolute(path);\n    var parts = exports.split(path);\n    // XXX needs to be sensitive to the root for\n    // Windows compatibility\n    if (parts.length) {\n        if (parts[parts.length - 1] == \"..\") {\n            parts.push(\"..\");\n        } else {\n            parts.pop();\n        }\n    } else {\n        parts.unshift(\"..\");\n    }\n    return parts.join(exports.SEPARATOR) || (\n        exports.isRelative(path) ?\n        \"\" : exports.ROOT\n    );\n};\n\n/**\n * @returns {String} the last component of a path, without\n * the given extension if the extension is provided and\n * matches the given file.\n * @param {String} path\n * @param {String} extention an optional extention to detect\n * and remove if it exists.\n */\nexports.base = function (path, extension) {\n    var base = path.split(exports.SEPARATORS_RE()).pop();\n    if (extension)\n        base = base.replace(\n            new RegExp(regExpEscape(extension) + \"$\"),\n            \"\"\n        );\n    return base;\n};\n\n/**\n * @returns {String} the extension (e.g., `txt`) of the file\n * at the given path.\n */\nexports.extension = function (path) {\n    path = exports.base(path);\n    path = path.replace(/^\\.*/, \"\");\n    var index = path.lastIndexOf(\".\");\n    return index <= 0 ? \"\" : path.substring(index);\n};\n\n})(typeof exports !== \"undefined\" ? exports : FS_BOOT = {});","blocks":{"total":54,"seen":31,"missing":23,"percentage":0.5740740740740741}},"hash":"4d9e40144354c4004e78cc80718347c8"},"/Users/kris/q-io/spec/fs/issues/1-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":31,"total":31,"coverage":{},"source":"require(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"write and remove\", function () {\n\n    it(\"should write and remove a file\", function () {\n\n        var fixture = FS.join(__dirname, \"fixture.txt\");\n\n        return FS.write(fixture, \"1234\")\n        .then(function (result) {\n            expect(result).toBe(undefined);\n        })\n\n        .then(function () {\n            return FS.remove(fixture);\n        })\n        .then(function (result) {\n            expect(result).toBe(undefined);\n        })\n\n        .then(function () {\n            return FS.exists(fixture)\n        })\n        .then(function (exists) {\n            expect(exists).toBe(false);\n        })\n\n    });\n});","blocks":{"total":7,"seen":7,"missing":0,"percentage":1}},"hash":"947436878d42ebecd4ba9e18e552009c"},"/Users/kris/q-io/spec/lib/jasmine-promise.js":{"stats":{"percentage":0.9024390243902439,"lines":[{"lineno":31},{"lineno":32},{"lineno":38},{"lineno":39}],"missing":4,"seen":37,"total":41,"coverage":{"31":{"partial":false,"source":"                spec.fail(error);","missing":[{"startCol":16,"endCol":32}]},"32":{"partial":false,"source":"                onComplete();","missing":[{"startCol":16,"endCol":28}]},"38":{"partial":false,"source":"        spec.fail(error);","missing":[{"startCol":8,"endCol":24}]},"39":{"partial":false,"source":"        onComplete();","missing":[{"startCol":8,"endCol":20}]}},"source":"\"use strict\";\n\nvar Q = require(\"q\");\n\n/**\n * Modifies the way that individual specs are run to easily test async\n * code with promises.\n *\n * A spec may return a promise. If it does, then the spec passes if and\n * only if that promise is fulfilled within a very short period of time.\n * If it is rejected, or if it isn't fulfilled quickly, the spec fails.\n *\n * In this way, we can use promise chaining to structure our asynchronous\n * tests. Expectations all down the chain of promises are all checked and\n * guaranteed to be run and resolved or the test fails.\n *\n * This is a big win over the runs() and watches() code that jasmine\n * supports out of the box.\n */\njasmine.Block.prototype.execute = function (onComplete) {\n    var spec = this.spec;\n    try {\n        var result = this.func.call(spec, onComplete);\n\n        // It seems Jasmine likes to return the suite if you pass it anything.\n        // So make sure it's a promise first.\n        if (result && typeof result.then === \"function\") {\n            Q.timeout(result, 500).then(function () {\n                onComplete();\n            }, function (error) {\n                spec.fail(error);\n                onComplete();\n            });\n        } else if (this.func.length === 0) {\n            onComplete();\n        }\n    } catch (error) {\n        spec.fail(error);\n        onComplete();\n    }\n};","blocks":{"total":7,"seen":5,"missing":2,"percentage":0.7142857142857143}},"hash":"e72b668dd4c4f55fae785bf5b9a21249"},"/Users/kris/q-io/fs.js":{"stats":{"percentage":0.7222222222222222,"lines":[{"lineno":30},{"lineno":36},{"lineno":37},{"lineno":38},{"lineno":40},{"lineno":66},{"lineno":69},{"lineno":77},{"lineno":96},{"lineno":97},{"lineno":106},{"lineno":108},{"lineno":109},{"lineno":110},{"lineno":112},{"lineno":117},{"lineno":118},{"lineno":119},{"lineno":120},{"lineno":122},{"lineno":123},{"lineno":125},{"lineno":128},{"lineno":132},{"lineno":133},{"lineno":134},{"lineno":136},{"lineno":137},{"lineno":139},{"lineno":142},{"lineno":152},{"lineno":153},{"lineno":179},{"lineno":210},{"lineno":214},{"lineno":215},{"lineno":217},{"lineno":219},{"lineno":220},{"lineno":222},{"lineno":226},{"lineno":228},{"lineno":232},{"lineno":233},{"lineno":235},{"lineno":237},{"lineno":238},{"lineno":240},{"lineno":244},{"lineno":246},{"lineno":250},{"lineno":251},{"lineno":252},{"lineno":254},{"lineno":256},{"lineno":257},{"lineno":259},{"lineno":263},{"lineno":265},{"lineno":277},{"lineno":278},{"lineno":280},{"lineno":281},{"lineno":282},{"lineno":283},{"lineno":285},{"lineno":287},{"lineno":288},{"lineno":290},{"lineno":294},{"lineno":296},{"lineno":300},{"lineno":301},{"lineno":303},{"lineno":305},{"lineno":306},{"lineno":308},{"lineno":312},{"lineno":314},{"lineno":318},{"lineno":319},{"lineno":320},{"lineno":322},{"lineno":324},{"lineno":325},{"lineno":327},{"lineno":331},{"lineno":333},{"lineno":337},{"lineno":338},{"lineno":340},{"lineno":341},{"lineno":343},{"lineno":346},{"lineno":350},{"lineno":351},{"lineno":353},{"lineno":354},{"lineno":356},{"lineno":359}],"missing":100,"seen":260,"total":360,"coverage":{"30":{"partial":true,"source":"        var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();","missing":[{"startCol":35,"endCol":56}]},"36":{"partial":false,"source":"                if (error.code === \"EMFILE\") {","missing":[{"startCol":20,"endCol":43}]},"37":{"partial":false,"source":"                    backOffDelay = (backOffDelay + 1) * backOffFactor;","missing":[{"startCol":20,"endCol":70},{"startCol":35,"endCol":53}]},"38":{"partial":false,"source":"                    return retry.apply(null, args);","missing":[{"startCol":20,"endCol":51},{"startCol":27,"endCol":50}]},"40":{"partial":false,"source":"                    throw error;","missing":[{"startCol":20,"endCol":32}]},"66":{"partial":false,"source":"        nodeOptions.bufferSize = options.bufferSize;","missing":[{"startCol":8,"endCol":52}]},"69":{"partial":false,"source":"        nodeOptions.mode = options.mode;","missing":[{"startCol":8,"endCol":40}]},"77":{"partial":false,"source":"            throw new Error(\"Can't open a binary file with a charset: \" + charset);","missing":[{"startCol":12,"endCol":83},{"startCol":28,"endCol":81}]},"96":{"partial":false,"source":"            error.message = \"Can't remove \" + JSON.stringify(path) + \": \" + error.message;","missing":[{"startCol":12,"endCol":90},{"startCol":28,"endCol":66},{"startCol":46,"endCol":66}]},"97":{"partial":false,"source":"            done.reject(error);","missing":[{"startCol":12,"endCol":30}]},"106":{"partial":false,"source":"    return Q.ninvoke(FS, \"rename\", String(source), String(target))","missing":[{"startCol":51,"endCol":65},{},{"startCol":35,"endCol":49},{"startCol":20,"endCol":66}]},"107":{"partial":false,"source":"    .fail(function (error) {","missing":[{}]},"108":{"partial":false,"source":"        error.message = (","missing":[{}]},"109":{"partial":false,"source":"            \"Can't move \" + JSON.stringify(source) + \" to \" +","missing":[{},{"startCol":12,"endCol":59},{"startCol":28,"endCol":50}]},"110":{"partial":false,"source":"            JSON.stringify(target) + \" because \" + error.message","missing":[{},{"startCol":12,"endCol":34}]},"111":{"partial":false,"source":"        );","missing":[{}]},"112":{"partial":false,"source":"        throw error;","missing":[{"startCol":8,"endCol":20},{}]},"113":{"partial":false,"source":"    });","missing":[{}]},"117":{"partial":false,"source":"    path = String(path);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"118":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"119":{"partial":false,"source":"    mode = mode === undefined ? parseInt('755', 8) : mode;","missing":[{"startCol":4,"endCol":58},{"startCol":11,"endCol":29},{"startCol":32,"endCol":50},{"startCol":53,"endCol":57}]},"120":{"partial":false,"source":"    FS.mkdir(path, mode, function (error) {","missing":[{}]},"121":{"partial":false,"source":"        if (error) {","missing":[{}]},"122":{"partial":false,"source":"            error.message = \"Can't makeDirectory \" + JSON.stringify(path) + \" with mode \" + mode + \": \" + error.message;","missing":[{"startCol":12,"endCol":120},{"startCol":28,"endCol":73},{},{"startCol":53,"endCol":73}]},"123":{"partial":false,"source":"            done.reject(error);","missing":[{},{"startCol":12,"endCol":30}]},"124":{"partial":false,"source":"        } else {","missing":[{}]},"125":{"partial":false,"source":"            done.resolve();","missing":[{},{"startCol":12,"endCol":26}]},"126":{"partial":false,"source":"        }","missing":[{}]},"127":{"partial":false,"source":"    });","missing":[{}]},"128":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"132":{"partial":false,"source":"    path = String(path);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"133":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"134":{"partial":false,"source":"    FS.rmdir(path, function (error) {","missing":[{}]},"135":{"partial":false,"source":"        if (error) {","missing":[{}]},"136":{"partial":false,"source":"            error.message = \"Can't removeDirectory \" + JSON.stringify(path) + \": \" + error.message;","missing":[{"startCol":12,"endCol":99},{},{"startCol":28,"endCol":75},{"startCol":55,"endCol":75}]},"137":{"partial":false,"source":"            done.reject(error);","missing":[{"startCol":12,"endCol":30},{}]},"138":{"partial":false,"source":"        } else {","missing":[{}]},"139":{"partial":false,"source":"            done.resolve();","missing":[{"startCol":12,"endCol":26},{}]},"140":{"partial":false,"source":"        }","missing":[{}]},"141":{"partial":false,"source":"    });","missing":[{}]},"142":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"152":{"partial":false,"source":"            error.message = \"Can't list \" + JSON.stringify(path) + \": \" + error.message;","missing":[{"startCol":12,"endCol":88},{"startCol":28,"endCol":64},{"startCol":44,"endCol":64}]},"153":{"partial":false,"source":"            return result.reject(error);","missing":[{"startCol":12,"endCol":40},{"startCol":19,"endCol":39}]},"179":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"210":{"partial":false,"source":"    return new Date(this.node.atime);","missing":[{"startCol":4,"endCol":37}]},"214":{"partial":false,"source":"    path = String(path);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"215":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"217":{"partial":false,"source":"        FS.lstat(path, function (error, stat) {","missing":[{}]},"218":{"partial":false,"source":"            if (error) {","missing":[{}]},"219":{"partial":false,"source":"                error.message = \"Can't statLink \" + JSON.stringify(path) + \": \" + error.message;","missing":[{},{"startCol":16,"endCol":96},{"startCol":32,"endCol":72},{"startCol":52,"endCol":72}]},"220":{"partial":false,"source":"                done.reject(error);","missing":[{},{"startCol":16,"endCol":35}]},"221":{"partial":false,"source":"            } else {","missing":[{}]},"222":{"partial":false,"source":"                done.resolve(stat);","missing":[{"startCol":16,"endCol":35},{}]},"223":{"partial":false,"source":"            }","missing":[{}]},"224":{"partial":false,"source":"        });","missing":[{}]},"226":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"228":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"232":{"partial":false,"source":"    fd = Number(fd);","missing":[{"startCol":4,"endCol":20},{"startCol":9,"endCol":19}]},"233":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"235":{"partial":false,"source":"        FS.fstat(fd, function (error, stat) {","missing":[{}]},"236":{"partial":false,"source":"            if (error) {","missing":[{}]},"237":{"partial":false,"source":"                error.message = \"Can't statFd file descriptor \" + JSON.stringify(fd) + \": \" + error.message;","missing":[{"startCol":16,"endCol":108},{"startCol":32,"endCol":84},{},{"startCol":66,"endCol":84}]},"238":{"partial":false,"source":"                done.reject(error);","missing":[{"startCol":16,"endCol":34},{}]},"239":{"partial":false,"source":"            } else {","missing":[{}]},"240":{"partial":false,"source":"                done.resolve(stat);","missing":[{},{"startCol":16,"endCol":34}]},"241":{"partial":false,"source":"            }","missing":[{}]},"242":{"partial":false,"source":"        });","missing":[{}]},"244":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"246":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"250":{"partial":false,"source":"    source = String(source);","missing":[{"startCol":4,"endCol":28},{"startCol":13,"endCol":27}]},"251":{"partial":false,"source":"    target = String(target);","missing":[{"startCol":4,"endCol":28},{"startCol":13,"endCol":27}]},"252":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"254":{"partial":false,"source":"        FS.link(source, target, function (error) {","missing":[{}]},"255":{"partial":false,"source":"            if (error) {","missing":[{}]},"256":{"partial":false,"source":"                error.message = \"Can't link \" + JSON.stringify(source) + \" to \" + JSON.stringify(target) + \": \" + error.message;","missing":[{"startCol":16,"endCol":128},{"startCol":32,"endCol":70},{},{"startCol":48,"endCol":70},{"startCol":82,"endCol":104}]},"257":{"partial":false,"source":"                done.reject(error);","missing":[{"startCol":16,"endCol":34},{}]},"258":{"partial":false,"source":"            } else {","missing":[{}]},"259":{"partial":false,"source":"                done.resolve();","missing":[{"startCol":16,"endCol":30},{}]},"260":{"partial":false,"source":"            }","missing":[{}]},"261":{"partial":false,"source":"        });","missing":[{}]},"263":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"265":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"277":{"partial":false,"source":"    if (!linkTypes.hasOwnProperty(type)) {","missing":[{"startCol":9,"endCol":39}]},"278":{"partial":false,"source":"        console.warn(new Error(\"For Windows compatibility, symbolicLink must be called with a type argument \\\"file\\\", \\\"directory\\\", or \\\"junction\\\"\"));","missing":[{"startCol":8,"endCol":151}]},"280":{"partial":false,"source":"    type = linkTypes[type];","missing":[{"startCol":4,"endCol":27}]},"281":{"partial":false,"source":"    target = String(target);","missing":[{"startCol":4,"endCol":28},{"startCol":13,"endCol":27}]},"282":{"partial":false,"source":"    relative = String(relative);","missing":[{"startCol":4,"endCol":32},{"startCol":15,"endCol":31}]},"283":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"285":{"partial":false,"source":"        FS.symlink(relative, target, type || 'file', function (error) {","missing":[{},{"startCol":37,"endCol":51}]},"286":{"partial":false,"source":"            if (error) {","missing":[{}]},"287":{"partial":false,"source":"                error.message = \"Can't create symbolicLink \" + JSON.stringify(target) + \" to relative location \" + JSON.stringify(relative) + \": \" + error.message;","missing":[{"startCol":16,"endCol":163},{"startCol":32,"endCol":85},{},{"startCol":63,"endCol":85},{"startCol":115,"endCol":139}]},"288":{"partial":false,"source":"                done.reject(error);","missing":[{"startCol":16,"endCol":34},{}]},"289":{"partial":false,"source":"            } else {","missing":[{}]},"290":{"partial":false,"source":"                done.resolve();","missing":[{},{"startCol":16,"endCol":31}]},"291":{"partial":false,"source":"            }","missing":[{}]},"292":{"partial":false,"source":"        });","missing":[{}]},"294":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"296":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"300":{"partial":false,"source":"    path = String(path);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"301":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"303":{"partial":false,"source":"        FS.chown(path, uid, gid, function (error) {","missing":[{}]},"304":{"partial":false,"source":"            if (error) {","missing":[{}]},"305":{"partial":false,"source":"                error.message = \"Can't chown (change owner) of \" + JSON.stringify(path) + \" to user \" + JSON.stringify(uid) + \" and group \" + JSON.stringify(gid) + \": \" + error.message;","missing":[{},{"startCol":16,"endCol":185},{"startCol":32,"endCol":87},{"startCol":67,"endCol":87},{"startCol":104,"endCol":123},{"startCol":142,"endCol":161}]},"306":{"partial":false,"source":"                done.reject(error);","missing":[{},{"startCol":16,"endCol":34}]},"307":{"partial":false,"source":"            } else {","missing":[{}]},"308":{"partial":false,"source":"                done.resolve();","missing":[{},{"startCol":16,"endCol":30}]},"309":{"partial":false,"source":"            }","missing":[{}]},"310":{"partial":false,"source":"        });","missing":[{}]},"312":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"314":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"318":{"partial":false,"source":"    path = String(path);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"319":{"partial":false,"source":"    mode = String(mode);","missing":[{"startCol":4,"endCol":24},{"startCol":11,"endCol":23}]},"320":{"partial":false,"source":"    var done = Q.defer();","missing":[{"startCol":4,"endCol":25},{"startCol":15,"endCol":24}]},"322":{"partial":false,"source":"        FS.chmod(path, mode, function (error) {","missing":[{}]},"323":{"partial":false,"source":"            if (error) {","missing":[{}]},"324":{"partial":false,"source":"                error.message = \"Can't chmod (change permissions mode) of \" + JSON.stringify(path) + \" to (octal number) \" + mode.toString(8) + \": \" + error.message;","missing":[{"startCol":16,"endCol":165},{"startCol":32,"endCol":98},{},{"startCol":78,"endCol":98},{"startCol":125,"endCol":141}]},"325":{"partial":false,"source":"                done.reject(error);","missing":[{"startCol":16,"endCol":34},{}]},"326":{"partial":false,"source":"            } else {","missing":[{}]},"327":{"partial":false,"source":"                done.resolve();","missing":[{},{"startCol":16,"endCol":30}]},"328":{"partial":false,"source":"            }","missing":[{}]},"329":{"partial":false,"source":"        });","missing":[{}]},"331":{"partial":false,"source":"        done.reject(error);","missing":[{"startCol":8,"endCol":26}]},"333":{"partial":false,"source":"    return done.promise;","missing":[{"startCol":4,"endCol":24}]},"337":{"partial":false,"source":"    var result = Q.defer();","missing":[{"startCol":4,"endCol":27},{"startCol":17,"endCol":26}]},"338":{"partial":false,"source":"    FS.realpath(path, function (error, canonicalPath) {","missing":[{}]},"339":{"partial":false,"source":"        if (error) {","missing":[{}]},"340":{"partial":false,"source":"            error.message = \"Can't get canonical path of \" + JSON.stringify(path) + \" by way of C realpath: \" + error.message;","missing":[{},{"startCol":12,"endCol":126},{"startCol":28,"endCol":125},{"startCol":61,"endCol":81}]},"341":{"partial":false,"source":"            result.reject(error);","missing":[{},{"startCol":12,"endCol":32}]},"342":{"partial":false,"source":"        } else {","missing":[{}]},"343":{"partial":false,"source":"            result.resolve(canonicalPath);","missing":[{},{"startCol":12,"endCol":41}]},"344":{"partial":false,"source":"        }","missing":[{}]},"345":{"partial":false,"source":"    });","missing":[{}]},"346":{"partial":false,"source":"    return result.promise;","missing":[{"startCol":4,"endCol":26}]},"350":{"partial":false,"source":"    var result = Q.defer();","missing":[{"startCol":4,"endCol":27},{"startCol":17,"endCol":26}]},"351":{"partial":false,"source":"    FS.readlink(path, function (error, path) {","missing":[{}]},"352":{"partial":false,"source":"        if (error) {","missing":[{}]},"353":{"partial":false,"source":"            error.message = \"Can't get link from \" + JSON.stringify(path) + \" by way of C readlink: \" + error.message;","missing":[{"startCol":12,"endCol":118},{"startCol":28,"endCol":73},{},{"startCol":53,"endCol":73}]},"354":{"partial":false,"source":"            result.reject(error);","missing":[{"startCol":12,"endCol":32},{}]},"355":{"partial":false,"source":"        } else {","missing":[{}]},"356":{"partial":false,"source":"            result.resolve(path);","missing":[{},{"startCol":12,"endCol":32}]},"357":{"partial":false,"source":"        }","missing":[{}]},"358":{"partial":false,"source":"    });","missing":[{}]},"359":{"partial":false,"source":"    return result.promise;","missing":[{"startCol":4,"endCol":26}]}},"source":"/**\n * An asynchronous local file system API, based on a subset\n * of the `narwhal/fs` API and the `narwhal/promise` API,\n * such that the method names are the same but some return\n * values are promises instead of fully resolved values.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar FS = require(\"fs\"); // node\nvar Q = require(\"q\");\nvar Reader = require(\"./reader\");\nvar Writer = require(\"./writer\");\nvar Common = require(\"./fs-common\");\nvar Mock = require(\"./fs-mock\");\nvar Root = require(\"./fs-root\");\n\nCommon.update(exports, process.cwd);\nexports.Mock = Mock;\nexports.mock = Mock.mock;\nexports.Root = Root;\n\n// facilitates AIMD (additive increase, multiplicative decrease) for backing off\nvar backOffDelay = 0;\nvar backOffFactor = 1.0001;\nfunction dampen(wrapped, thisp) {\n    var retry = function () {\n        var args = arguments;\n        var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();\n        return ready.then(function () {\n            return Q.when(wrapped.apply(thisp, args), function (stream) {\n                backOffDelay = Math.max(0, backOffDelay - 1);\n                return stream;\n            }, function (error) {\n                if (error.code === \"EMFILE\") {\n                    backOffDelay = (backOffDelay + 1) * backOffFactor;\n                    return retry.apply(null, args);\n                } else {\n                    throw error;\n                }\n            });\n        });\n    };\n    return retry;\n}\n\n/**\n * @param {String} path\n * @param {Object} options (flags, mode, bufferSize, charset, begin, end)\n * @returns {Promise * Stream} a stream from the `q-io` module.\n */\nexports.open = dampen(function (path, flags, charset, options) {\n    var self = this;\n    if (typeof flags == \"object\") {\n        options = flags;\n        flags = options.flags;\n        charset = options.charset;\n    }\n    options = options || {};\n    flags = flags || \"r\";\n    var nodeOptions = {\n        \"flags\": flags.replace(/b/g, \"\")\n    };\n    if (\"bufferSize\" in options) {\n        nodeOptions.bufferSize = options.bufferSize;\n    }\n    if (\"mode\" in options) {\n        nodeOptions.mode = options.mode;\n    }\n    if (\"begin\" in options) {\n        nodeOptions.start = options.begin;\n        nodeOptions.end = options.end - 1;\n    }\n    if (flags.indexOf(\"b\") >= 0) {\n        if (charset) {\n            throw new Error(\"Can't open a binary file with a charset: \" + charset);\n        }\n    } else {\n        charset = charset || 'utf-8';\n    }\n    if (flags.indexOf(\"w\") >= 0) {\n        var stream = FS.createWriteStream(String(path), nodeOptions);\n        return Writer(stream, charset);\n    } else {\n        var stream = FS.createReadStream(String(path), nodeOptions);\n        return Reader(stream, charset);\n    }\n});\n\nexports.remove = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    FS.unlink(path, function (error) {\n        if (error) {\n            error.message = \"Can't remove \" + JSON.stringify(path) + \": \" + error.message;\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\nexports.move = function (source, target) {\n    return Q.ninvoke(FS, \"rename\", String(source), String(target))\n    .fail(function (error) {\n        error.message = (\n            \"Can't move \" + JSON.stringify(source) + \" to \" +\n            JSON.stringify(target) + \" because \" + error.message\n        );\n        throw error;\n    });\n};\n\nexports.makeDirectory = function (path, mode) {\n    path = String(path);\n    var done = Q.defer();\n    mode = mode === undefined ? parseInt('755', 8) : mode;\n    FS.mkdir(path, mode, function (error) {\n        if (error) {\n            error.message = \"Can't makeDirectory \" + JSON.stringify(path) + \" with mode \" + mode + \": \" + error.message;\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\nexports.removeDirectory = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    FS.rmdir(path, function (error) {\n        if (error) {\n            error.message = \"Can't removeDirectory \" + JSON.stringify(path) + \": \" + error.message;\n            done.reject(error);\n        } else {\n            done.resolve();\n        }\n    });\n    return done.promise;\n};\n\n/**\n */\nexports.list = dampen(function (path) {\n    path = String(path);\n    var result = Q.defer();\n    FS.readdir(path, function (error, list) {\n        if (error) {\n            error.message = \"Can't list \" + JSON.stringify(path) + \": \" + error.message;\n            return result.reject(error);\n        } else {\n            result.resolve(list);\n        }\n    });\n    return result.promise;\n});\n\n/**\n * @param {String} path\n * @returns {Promise * Stat}\n */\nexports.stat = function (path) {\n    var self = this;\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.stat(path, function (error, stat) {\n            if (error) {\n                error.message = \"Can't stat \" + JSON.stringify(path) + \": \" + error;\n                done.reject(error);\n            } else {\n                done.resolve(new Stats(stat));\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nvar Stats = function (nodeStat) {\n    this.node = nodeStat;\n    this.size = nodeStat.size;\n};\n\nvar stats = [\n    \"isDirectory\",\n    \"isFile\",\n    \"isBlockDevice\",\n    \"isCharacterDevice\",\n    \"isSymbolicLink\",\n    \"isFIFO\",\n    \"isSocket\"\n];\n\nstats.forEach(function (name) {\n    Stats.prototype[name] = function () {\n        return this.node[name]();\n    };\n});\n\nStats.prototype.lastModified = function () {\n    return new Date(this.node.mtime);\n};\n\nStats.prototype.lastAccessed = function () {\n    return new Date(this.node.atime);\n};\n\nexports.statLink = function (path) {\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.lstat(path, function (error, stat) {\n            if (error) {\n                error.message = \"Can't statLink \" + JSON.stringify(path) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve(stat);\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.statFd = function (fd) {\n    fd = Number(fd);\n    var done = Q.defer();\n    try {\n        FS.fstat(fd, function (error, stat) {\n            if (error) {\n                error.message = \"Can't statFd file descriptor \" + JSON.stringify(fd) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve(stat);\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.link = function (source, target) {\n    source = String(source);\n    target = String(target);\n    var done = Q.defer();\n    try {\n        FS.link(source, target, function (error) {\n            if (error) {\n                error.message = \"Can't link \" + JSON.stringify(source) + \" to \" + JSON.stringify(target) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\n// this lookup table translates the link types that Q-IO accepts (which have\n// been normalized to full words to be consistent with the naming convention)\nvar linkTypes = {\n    \"file\": \"file\",\n    \"directory\": \"dir\",\n    \"junction\": \"junction\"\n};\n\nexports.symbolicLink = function (target, relative, type) {\n    if (!linkTypes.hasOwnProperty(type)) {\n        console.warn(new Error(\"For Windows compatibility, symbolicLink must be called with a type argument \\\"file\\\", \\\"directory\\\", or \\\"junction\\\"\"));\n    }\n    type = linkTypes[type];\n    target = String(target);\n    relative = String(relative);\n    var done = Q.defer();\n    try {\n        FS.symlink(relative, target, type || 'file', function (error) {\n            if (error) {\n                error.message = \"Can't create symbolicLink \" + JSON.stringify(target) + \" to relative location \" + JSON.stringify(relative) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.chown = function (path, uid, gid) {\n    path = String(path);\n    var done = Q.defer();\n    try {\n        FS.chown(path, uid, gid, function (error) {\n            if (error) {\n                error.message = \"Can't chown (change owner) of \" + JSON.stringify(path) + \" to user \" + JSON.stringify(uid) + \" and group \" + JSON.stringify(gid) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.chmod = function (path, mode) {\n    path = String(path);\n    mode = String(mode);\n    var done = Q.defer();\n    try {\n        FS.chmod(path, mode, function (error) {\n            if (error) {\n                error.message = \"Can't chmod (change permissions mode) of \" + JSON.stringify(path) + \" to (octal number) \" + mode.toString(8) + \": \" + error.message;\n                done.reject(error);\n            } else {\n                done.resolve();\n            }\n        });\n    } catch (error) {\n        done.reject(error);\n    }\n    return done.promise;\n};\n\nexports.canonical = function (path) {\n    var result = Q.defer();\n    FS.realpath(path, function (error, canonicalPath) {\n        if (error) {\n            error.message = \"Can't get canonical path of \" + JSON.stringify(path) + \" by way of C realpath: \" + error.message;\n            result.reject(error);\n        } else {\n            result.resolve(canonicalPath);\n        }\n    });\n    return result.promise;\n};\n\nexports.readLink = function (path) {\n    var result = Q.defer();\n    FS.readlink(path, function (error, path) {\n        if (error) {\n            error.message = \"Can't get link from \" + JSON.stringify(path) + \" by way of C readlink: \" + error.message;\n            result.reject(error);\n        } else {\n            result.resolve(path);\n        }\n    });\n    return result.promise;\n};","blocks":{"total":91,"seen":26,"missing":65,"percentage":0.2857142857142857}},"hash":"4732d2925529d6241ce761a2b1ffd281"},"/Users/kris/q-io/reader.js":{"stats":{"percentage":0.937984496124031,"lines":[{"lineno":23},{"lineno":37},{"lineno":86},{"lineno":97},{"lineno":98},{"lineno":99},{"lineno":102},{"lineno":104}],"missing":8,"seen":121,"total":129,"coverage":{"23":{"partial":false,"source":"        begin.reject(reason);","missing":[{"startCol":8,"endCol":28}]},"37":{"partial":false,"source":"            receiver(chunk);","missing":[{"startCol":12,"endCol":27}]},"86":{"partial":false,"source":"        _stream.destroy();","missing":[{"startCol":8,"endCol":25}]},"97":{"partial":false,"source":"    var chunks = [];","missing":[{"startCol":4,"endCol":20}]},"98":{"partial":false,"source":"    stream.forEach(function (chunk) {","missing":[{}]},"99":{"partial":false,"source":"        chunks.push(chunk);","missing":[{},{"startCol":8,"endCol":26}]},"100":{"partial":false,"source":"    });","missing":[{}]},"102":{"partial":false,"source":"        return chunks.join(\"\");","missing":[{"startCol":8,"endCol":31},{"startCol":15,"endCol":30}]},"104":{"partial":false,"source":"        return join(chunks);","missing":[{"startCol":8,"endCol":28},{"startCol":15,"endCol":27}]}},"source":"var Q = require(\"q\");\n\n/**\n * Wraps a Node readable stream, providing an API similar\n * to a Narwhal synchronous `io` stream except returning\n * Q promises for long latency operations.\n * @param stream any Node readable stream\n * @returns {Promise * Reader} a promise for\n * the text stream reader.\n * @constructor\n */\nmodule.exports = Reader;\nfunction Reader(_stream, charset) {\n    var self = Object.create(Reader.prototype);\n\n    if (charset && _stream.setEncoding) // TODO complain about inconsistency\n        _stream.setEncoding(charset);\n\n    var begin = Q.defer();\n    var end = Q.defer();\n\n    _stream.on(\"error\", function (reason) {\n        begin.reject(reason);\n    });\n\n    var chunks = [];\n    var receiver;\n\n    _stream.on(\"end\", function () {\n        begin.resolve(self);\n        end.resolve()\n    });\n\n    _stream.on(\"data\", function (chunk) {\n        begin.resolve(self);\n        if (receiver) {\n            receiver(chunk);\n        } else {\n            chunks.push(chunk);\n        }\n    });\n\n    function slurp() {\n        var result;\n        if (charset) {\n            result = chunks.join(\"\");\n        } else {\n            result = self.constructor.join(chunks);\n        }\n        chunks.splice(0, chunks.length);\n        return result;\n    }\n\n    /***\n     * Reads all of the remaining data from the stream.\n     * @returns {Promise * String} a promise for a String\n     * containing the entirety the remaining stream.\n     */\n    self.read = function () {\n        receiver = undefined;\n        var deferred = Q.defer();\n        Q.done(end.promise, function () {\n            deferred.resolve(slurp());\n        });\n        return deferred.promise;\n    };\n\n    /***\n     * Reads and writes all of the remaining data from the\n     * stream in chunks.\n     * @param {Function(Promise * String)} write a function\n     * to be called on each chunk of input from this stream.\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the input is depleted.\n     */\n    self.forEach = function (write) {\n        if (chunks && chunks.length)\n            write(slurp());\n        receiver = write;\n        return Q.when(end.promise, function () {\n            receiver = undefined;\n        });\n    };\n\n    self.close = function () {\n        _stream.destroy();\n    };\n\n    return begin.promise;\n}\n\n/*\n    Reads an entire forEachable stream of buffers and returns a single buffer.\n*/\nReader.read = read;\nfunction read(stream, charset) {\n    var chunks = [];\n    stream.forEach(function (chunk) {\n        chunks.push(chunk);\n    });\n    if (charset) {\n        return chunks.join(\"\");\n    } else {\n        return join(chunks);\n    }\n}\n\nReader.join = join;\nfunction join(buffers) {\n    var length = 0;\n    var at;\n    var i;\n    var ii = buffers.length;\n    var buffer;\n    var result;\n    for (i = 0; i < ii; i++) {\n        buffer = buffers[i];\n        length += buffer.length;\n    }\n    result = new Buffer(length);\n    at = 0;\n    for (i = 0; i < ii; i++) {\n        buffer = buffers[i];\n        buffer.copy(result, at, 0);\n        at += buffer.length;\n    }\n    buffers.splice(0, ii, result);\n    return result;\n}","blocks":{"total":23,"seen":16,"missing":7,"percentage":0.6956521739130435}},"hash":"24c2b103d427c684f91c5cc6d3968af8"},"/Users/kris/q-io/writer.js":{"stats":{"percentage":0.9080459770114943,"lines":[{"lineno":17},{"lineno":23},{"lineno":41},{"lineno":45},{"lineno":56},{"lineno":81},{"lineno":82},{"lineno":83}],"missing":8,"seen":79,"total":87,"coverage":{"17":{"partial":false,"source":"        _stream.setEncoding(charset);","missing":[{"startCol":8,"endCol":36}]},"23":{"partial":false,"source":"        begin.reject(reason);","missing":[{"startCol":8,"endCol":28}]},"41":{"partial":false,"source":"            return Q.reject(new Error(\"Can't write to non-writable (possibly closed) stream\"));","missing":[{"startCol":12,"endCol":95},{"startCol":19,"endCol":94}]},"45":{"partial":false,"source":"            return Q.resolve();","missing":[{"startCol":12,"endCol":31},{"startCol":19,"endCol":30}]},"56":{"partial":false,"source":"        return drained.promise;","missing":[{"startCol":8,"endCol":31}]},"81":{"partial":false,"source":"        _stream.destroy();","missing":[{"startCol":8,"endCol":25}]},"82":{"partial":false,"source":"        drained.resolve(); // we will get no further drain events","missing":[{"startCol":8,"endCol":25}]},"83":{"partial":false,"source":"        return Q.resolve(); // destruction not explicitly observable","missing":[{"startCol":8,"endCol":27},{"startCol":15,"endCol":26}]}},"source":"var Q = require(\"q\");\n\n/**\n * Wraps a Node writable stream, providing an API similar to\n * Narwhal's synchronous `io` streams, except returning and\n * accepting promises for long-latency operations.\n *\n * @param stream any Node writable stream\n * @returns {Promise * Writer} a promise for the\n * text writer.\n */\nmodule.exports = Writer;\nfunction Writer(_stream, charset) {\n    var self = Object.create(Writer.prototype);\n\n    if (charset && _stream.setEncoding) // TODO complain about inconsistency\n        _stream.setEncoding(charset);\n\n    var begin = Q.defer();\n    var drained = Q.defer();\n\n    _stream.on(\"error\", function (reason) {\n        begin.reject(reason);\n    });\n\n    _stream.on(\"drain\", function () {\n        begin.resolve(self);\n        drained.resolve();\n        drained = Q.defer();\n    });\n\n    /***\n     * Writes content to the stream.\n     * @param {String} content\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the buffer is empty, meaning\n     * that all of the content has been sent.\n     */\n    self.write = function (content) {\n        if (!_stream.writeable && !_stream.writable)\n            return Q.reject(new Error(\"Can't write to non-writable (possibly closed) stream\"));\n        if (!_stream.write(content)) {\n            return drained.promise;\n        } else {\n            return Q.resolve();\n        }\n    };\n\n    /***\n     * Waits for all data to flush on the stream.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the buffer is empty\n     */\n    self.flush = function () {\n        return drained.promise;\n    };\n\n    /***\n     * Closes the stream, waiting for the internal buffer\n     * to flush.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the stream has finished writing,\n     * flushing, and closed.\n     */\n    self.close = function () {\n        _stream.end();\n        drained.resolve(); // we will get no further drain events\n        return Q.resolve(); // closing not explicitly observable\n    };\n\n    /***\n     * Terminates writing on a stream, closing before\n     * the internal buffer drains.\n     *\n     * @returns {Promise * Undefined} a promise that will\n     * be resolved when the stream has finished closing.\n     */\n    self.destroy = function () {\n        _stream.destroy();\n        drained.resolve(); // we will get no further drain events\n        return Q.resolve(); // destruction not explicitly observable\n    };\n\n    return Q.resolve(self); // todo returns the begin.promise\n}","blocks":{"total":11,"seen":5,"missing":6,"percentage":0.45454545454545453}},"hash":"17cc8ce63050c0045f908ac78f4f87cd"},"/Users/kris/q-io/fs-common.js":{"stats":{"percentage":0.8706467661691543,"lines":[{"lineno":37},{"lineno":38},{"lineno":39},{"lineno":40},{"lineno":41},{"lineno":55},{"lineno":70},{"lineno":71},{"lineno":72},{"lineno":74},{"lineno":75},{"lineno":76},{"lineno":78},{"lineno":79},{"lineno":80},{"lineno":81},{"lineno":119},{"lineno":120},{"lineno":140},{"lineno":159},{"lineno":164},{"lineno":165},{"lineno":174},{"lineno":182},{"lineno":183},{"lineno":185},{"lineno":196},{"lineno":233},{"lineno":254},{"lineno":255},{"lineno":259},{"lineno":260},{"lineno":273},{"lineno":296},{"lineno":297},{"lineno":304},{"lineno":305},{"lineno":322},{"lineno":323},{"lineno":334},{"lineno":335},{"lineno":337},{"lineno":347},{"lineno":348},{"lineno":349},{"lineno":350},{"lineno":351},{"lineno":352},{"lineno":353},{"lineno":354},{"lineno":355},{"lineno":357}],"missing":52,"seen":350,"total":402,"coverage":{"37":{"partial":false,"source":"            error.message = \"Can't read \" + path + \" because \" + error.message;","missing":[{"startCol":12,"endCol":79},{"startCol":28,"endCol":48}]},"38":{"partial":false,"source":"            error.path = path;","missing":[{"startCol":12,"endCol":30}]},"39":{"partial":false,"source":"            error.flags = flags;","missing":[{"startCol":12,"endCol":32}]},"40":{"partial":false,"source":"            error.charset = charset;","missing":[{"startCol":12,"endCol":36}]},"41":{"partial":false,"source":"            throw error;","missing":[{"startCol":12,"endCol":24}]},"55":{"partial":false,"source":"            options = flags;","missing":[{"startCol":12,"endCol":28}]},"70":{"partial":false,"source":"        var self = this;","missing":[{"startCol":8,"endCol":24}]},"71":{"partial":false,"source":"        if (typeof flags == \"object\") {","missing":[{"startCol":12,"endCol":36}]},"72":{"partial":false,"source":"            options = flags;","missing":[{"startCol":12,"endCol":28}]},"74":{"partial":false,"source":"            options = options || {};","missing":[{"startCol":12,"endCol":36},{"startCol":22,"endCol":35}]},"75":{"partial":false,"source":"            options.flags = flags;","missing":[{"startCol":12,"endCol":34}]},"76":{"partial":false,"source":"            options.carset = charset;","missing":[{"startCol":12,"endCol":37}]},"78":{"partial":false,"source":"        options.flags = \"w+\" + (options.flags || \"\").replace(/[w\\+]/g, \"\");","missing":[{"startCol":8,"endCol":75},{"startCol":24,"endCol":74},{"startCol":31,"endCol":52}]},"79":{"partial":false,"source":"        return Q.when(self.open(path, options), function (stream) {","missing":[{"startCol":22,"endCol":46},{}]},"80":{"partial":false,"source":"            return Q.when(stream.write(content), function () {","missing":[{},{"startCol":26,"endCol":47}]},"81":{"partial":false,"source":"                return stream.close();","missing":[{"startCol":16,"endCol":38},{},{"startCol":23,"endCol":37}]},"82":{"partial":false,"source":"            });","missing":[{}]},"83":{"partial":false,"source":"        });","missing":[{}]},"119":{"partial":false,"source":"            } else if (stat.isSymbolicLink()) {","missing":[{"startCol":23,"endCol":44}]},"120":{"partial":false,"source":"                return self.symbolicCopy(source, target);","missing":[{"startCol":16,"endCol":57},{"startCol":23,"endCol":56}]},"140":{"partial":false,"source":"                return Q.reject(exception);","missing":[{"startCol":16,"endCol":43},{"startCol":23,"endCol":42}]},"159":{"partial":false,"source":"            return [];","missing":[{"startCol":12,"endCol":22}]},"164":{"partial":false,"source":"        return this.listTree(path, function (path, stat) {","missing":[{}]},"165":{"partial":false,"source":"            return stat.isDirectory();","missing":[{},{"startCol":12,"endCol":38},{"startCol":19,"endCol":37}]},"166":{"partial":false,"source":"        });","missing":[{}]},"174":{"partial":false,"source":"            at.push(self.ROOT);","missing":[{"startCol":12,"endCol":30}]},"182":{"partial":false,"source":"                    if (reason.code == \"EEXIST\" || reason.code == \"EISDIR\") {","missing":[{"startCol":24,"endCol":47},{"startCol":51,"endCol":74}]},"183":{"partial":false,"source":"                        return;","missing":[{"startCol":24,"endCol":31}]},"185":{"partial":false,"source":"                        return Q.reject(reason);","missing":[{"startCol":24,"endCol":48},{"startCol":31,"endCol":47}]},"196":{"partial":false,"source":"                return self.remove(path);","missing":[{"startCol":16,"endCol":41},{"startCol":23,"endCol":40}]},"233":{"partial":false,"source":"            return false;","missing":[{"startCol":12,"endCol":25}]},"254":{"partial":false,"source":"        var self = this;","missing":[{"startCol":8,"endCol":24}]},"255":{"partial":false,"source":"        return self.stat(path).invoke('lastModified');","missing":[{"startCol":8,"endCol":54},{"startCol":15,"endCol":53},{"startCol":24,"endCol":30}]},"259":{"partial":false,"source":"        var self = this;","missing":[{"startCol":8,"endCol":24}]},"260":{"partial":false,"source":"        return self.stat(path).invoke('lastAccessed');","missing":[{"startCol":8,"endCol":54},{"startCol":15,"endCol":53},{"startCol":24,"endCol":30}]},"273":{"partial":false,"source":"                return self.relativeFromDirectory(source, target);","missing":[{"startCol":16,"endCol":66},{"startCol":23,"endCol":65}]},"296":{"partial":false,"source":"            source.shift();","missing":[{"startCol":12,"endCol":26}]},"297":{"partial":false,"source":"            target.unshift(\"..\");","missing":[{"startCol":12,"endCol":32}]},"304":{"partial":false,"source":"            target = source;","missing":[{"startCol":12,"endCol":28}]},"305":{"partial":false,"source":"            source = workingDirectory();","missing":[{"startCol":12,"endCol":40},{"startCol":21,"endCol":39}]},"322":{"partial":false,"source":"            source.shift();","missing":[{"startCol":12,"endCol":26}]},"323":{"partial":false,"source":"            target.unshift(\"..\");","missing":[{"startCol":12,"endCol":32}]},"334":{"partial":true,"source":"        if (parent.length === 2 && parent[1] === \"\")","missing":[{"startCol":35,"endCol":51}]},"335":{"partial":false,"source":"            parent.pop();","missing":[{"startCol":12,"endCol":24}]},"337":{"partial":false,"source":"            return false;","missing":[{"startCol":12,"endCol":25}]},"347":{"partial":false,"source":"        var self = this;","missing":[{"startCol":8,"endCol":24}]},"348":{"partial":false,"source":"        path = path || this.ROOT;","missing":[{"startCol":8,"endCol":33},{"startCol":15,"endCol":32}]},"349":{"partial":false,"source":"        return Q.when(this.list(path), function (list) {","missing":[{},{"startCol":22,"endCol":37}]},"350":{"partial":false,"source":"            if (list.length !== 1)","missing":[{},{"startCol":16,"endCol":33}]},"351":{"partial":false,"source":"                return RootFs(self, path);","missing":[{"startCol":16,"endCol":42},{"startCol":23,"endCol":41},{}]},"352":{"partial":false,"source":"            var nextPath = self.join(path, list[0]);","missing":[{"startCol":12,"endCol":52},{},{"startCol":27,"endCol":51}]},"353":{"partial":false,"source":"            return Q.when(self.stat(nextPath), function (stat) {","missing":[{},{"startCol":26,"endCol":45}]},"354":{"partial":false,"source":"                if (stat.isDirectory()) {","missing":[{"startCol":20,"endCol":38},{}]},"355":{"partial":false,"source":"                    return reroot(nextPath);","missing":[{"startCol":27,"endCol":43},{},{"startCol":20,"endCol":44}]},"356":{"partial":false,"source":"                } else {","missing":[{}]},"357":{"partial":false,"source":"                    return RootFs(self, path);","missing":[{"startCol":27,"endCol":45},{"startCol":20,"endCol":46},{}]},"358":{"partial":false,"source":"                }","missing":[{}]},"359":{"partial":false,"source":"            });","missing":[{}]},"360":{"partial":false,"source":"        });","missing":[{}]}},"source":"var Q = require(\"q\");\nvar Boot = require(\"./fs-boot\");\nvar RootFs = require(\"./fs-root\");\nvar MockFs = require(\"./fs-mock\");\n\n// TODO patternToRegExp\n// TODO glob\n// TODO match\n\nvar concat = function (arrays) {\n    return Array.prototype.concat.apply([], arrays);\n};\n\nexports.update = function (exports, workingDirectory) {\n\n    for (var name in Boot) {\n        exports[name] = Boot[name];\n    }\n\n    /**\n     * @param {String} path\n     * @param {Object} options\n     * @returns {Promise * (String || Buffer)}\n     */\n    exports.read = function (path, flags, charset, options) {\n        if (typeof flags == \"object\") {\n            options = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.carset = charset;\n        }\n        options.flags = \"r\" + (options.flags || \"\").replace(/r/g, \"\");\n        return Q.when(this.open(path, options), function (stream) {\n            return stream.read();\n        }, function (error) {\n            error.message = \"Can't read \" + path + \" because \" + error.message;\n            error.path = path;\n            error.flags = flags;\n            error.charset = charset;\n            throw error;\n        });\n    };\n\n    /**\n     * @param {String} path\n     * @param {String || Buffer} content\n     * @param {Object} options\n     * @returns {Promise * Undefined} a promise that resolves\n     * when the writing is complete.\n     */\n    exports.write = function (path, content, flags, charset, options) {\n        var self = this;\n        if (typeof flags == \"object\") {\n            options = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.carset = charset;\n        }\n        options.flags = \"w\" + (options.flags || \"\").replace(/w/g, \"\");\n        return Q.when(self.open(path, options), function (stream) {\n            return Q.when(stream.write(content), function () {\n                return stream.close();\n            });\n        });\n    };\n\n    exports.append = function (path, content, flags, charset, options) {\n        var self = this;\n        if (typeof flags == \"object\") {\n            options = flags;\n        } else {\n            options = options || {};\n            options.flags = flags;\n            options.carset = charset;\n        }\n        options.flags = \"w+\" + (options.flags || \"\").replace(/[w\\+]/g, \"\");\n        return Q.when(self.open(path, options), function (stream) {\n            return Q.when(stream.write(content), function () {\n                return stream.close();\n            });\n        });\n    };\n\n    exports.copy = function (source, target) {\n        var self = this;\n        return Q.spread([\n            self.open(source, {flags: \"rb\"}),\n            self.open(target, {flags: \"wb\"})\n        ], function (reader, writer) {\n            return Q.when(reader.forEach(function (block) {\n                return writer.write(block);\n            }), function () {\n                return Q.all([\n                    reader.close(),\n                    writer.close()\n                ]);\n            });\n        });\n    };\n\n    exports.copyTree = function (source, target) {\n        var self = this;\n        return Q.when(self.stat(source), function (stat) {\n            if (stat.isFile()) {\n                return self.copy(source, target);\n            } else if (stat.isDirectory()) {\n                return Q.when(self.makeDirectory(target), function () {\n                    return Q.when(self.list(source), function (list) {\n                        return Q.all(list.map(function (child) {\n                            return self.copyTree(\n                                self.join(source, child),\n                                self.join(target, child)\n                            );\n                        }));\n                    });\n                });\n            } else if (stat.isSymbolicLink()) {\n                return self.symbolicCopy(source, target);\n            }\n        });\n    };\n\n    exports.listTree = function (basePath, guard) {\n        var self = this;\n        basePath = String(basePath || '');\n        if (!basePath)\n            basePath = \".\";\n        guard = guard || function () {\n            return true;\n        };\n        var stat = self.stat(basePath);\n        return Q.when(stat, function (stat) {\n            var paths = [];\n            var mode; // true:include, false:exclude, null:no-recur\n            try {\n                var include = guard(basePath, stat);\n            } catch (exception) {\n                return Q.reject(exception);\n            }\n            return Q.when(include, function (include) {\n                if (include) {\n                    paths.push([basePath]);\n                }\n                if (include !== null && stat.isDirectory()) {\n                    return Q.when(self.list(basePath), function (children) {\n                        paths.push.apply(paths, children.map(function (child) {\n                            var path = self.join(basePath, child);\n                            return self.listTree(path, guard);\n                        }));\n                        return paths;\n                    });\n                } else {\n                    return paths;\n                }\n            });\n        }, function noSuchFile(reason) {\n            return [];\n        }).then(Q.all).then(concat);\n    };\n\n    exports.listDirectoryTree = function (path) {\n        return this.listTree(path, function (path, stat) {\n            return stat.isDirectory();\n        });\n    };\n\n    exports.makeTree = function (path, mode) {\n        var self = this;\n        var parts = self.split(path);\n        var at = [];\n        if (self.isAbsolute(path))\n            at.push(self.ROOT);\n        return parts.reduce(function (parent, part) {\n            return Q.when(parent, function () {\n                at.push(part);\n                var parts = self.join(at);\n                var made = self.makeDirectory(parts, mode);\n                return Q.when(made, null, function rejected(reason) {\n                    // throw away errors for already made directories\n                    if (reason.code == \"EEXIST\" || reason.code == \"EISDIR\") {\n                        return;\n                    } else {\n                        return Q.reject(reason);\n                    }\n                });\n            });\n        }, undefined);\n    };\n\n    exports.removeTree = function (path) {\n        var self = this;\n        return Q.when(self.stat(path), function (stat) {\n            if (stat.isSymbolicLink()) {\n                return self.remove(path);\n            } else if (stat.isDirectory()) {\n                return self.list(path)\n                .then(function (list) {\n                    // asynchronously remove every subtree\n                    return Q.all(list.map(function (name) {\n                        return self.removeTree(self.join(path, name));\n                    }))\n                    .then(function () {\n                        return self.removeDirectory(path);\n                    });\n                });\n            } else {\n                return self.remove(path);\n            }\n        });\n    };\n\n    exports.symbolicCopy = function (source, target) {\n        var self = this;\n        return Q.when(self.relative(target, source), function (relative) {\n            return self.symbolicLink(target, relative, \"file\");\n        });\n    };\n\n    exports.exists = function (path) {\n        return Q.when(this.stat(path), function () {\n            return true;\n        }, function () {\n            return false;\n        });\n    };\n\n    exports.isFile = function (path) {\n        return Q.when(this.stat(path), function (stat) {\n            return stat.isFile();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.isDirectory = function (path) {\n        return Q.when(this.stat(path), function (stat) {\n            return stat.isDirectory();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.isSymbolicLink = function (path) {\n        return Q.when(this.statLink(path), function (stat) {\n            return stat.isSymbolicLink();\n        }, function (reason) {\n            return false;\n        });\n    };\n\n    exports.lastModified = function (path) {\n        var self = this;\n        return self.stat(path).invoke('lastModified');\n    };\n\n    exports.lastAccessed = function (path) {\n        var self = this;\n        return self.stat(path).invoke('lastAccessed');\n    };\n\n    exports.absolute = function (path) {\n        if (this.isAbsolute(path))\n            return path;\n        return this.join(workingDirectory(), path);\n    };\n\n    exports.relative = function (source, target) {\n        var self = this;\n        return Q.when(this.isDirectory(source), function (isDirectory) {\n            if (isDirectory) {\n                return self.relativeFromDirectory(source, target);\n            } else {\n                return self.relativeFromFile(source, target);\n            }\n        });\n    };\n\n    exports.relativeFromFile = function (source, target) {\n        var self = this;\n        source = self.absolute(source);\n        target = self.absolute(target);\n        source = source.split(self.SEPARATORS_RE());\n        target = target.split(self.SEPARATORS_RE());\n        source.pop();\n        while (\n            source.length &&\n            target.length &&\n            target[0] == source[0]\n        ) {\n            source.shift();\n            target.shift();\n        }\n        while (source.length) {\n            source.shift();\n            target.unshift(\"..\");\n        }\n        return target.join(self.SEPARATOR);\n    };\n\n    exports.relativeFromDirectory = function (source, target) {\n        if (!target) {\n            target = source;\n            source = workingDirectory();\n        }\n        source = this.absolute(source);\n        target = this.absolute(target);\n        source = source.split(this.SEPARATORS_RE());\n        target = target.split(this.SEPARATORS_RE());\n        if (source.length === 2 && source[1] === \"\")\n            source.pop();\n        while (\n            source.length &&\n            target.length &&\n            target[0] == source[0]\n        ) {\n            source.shift();\n            target.shift();\n        }\n        while (source.length) {\n            source.shift();\n            target.unshift(\"..\");\n        }\n        return target.join(this.SEPARATOR);\n    };\n\n    exports.contains = function (parent, child) {\n        var i, ii;\n        parent = this.absolute(parent);\n        child = this.absolute(child);\n        parent = parent.split(this.SEPARATORS_RE());\n        child = child.split(this.SEPARATORS_RE());\n        if (parent.length === 2 && parent[1] === \"\")\n            parent.pop();\n        if (parent.length > child.length)\n            return false;\n        for (i = 0, ii = parent.length; i < ii; i++) {\n            if (parent[i] !== child[i])\n                break;\n        }\n        return i == ii;\n    };\n\n    exports.reroot = reroot;\n    function reroot(path) {\n        var self = this;\n        path = path || this.ROOT;\n        return Q.when(this.list(path), function (list) {\n            if (list.length !== 1)\n                return RootFs(self, path);\n            var nextPath = self.join(path, list[0]);\n            return Q.when(self.stat(nextPath), function (stat) {\n                if (stat.isDirectory()) {\n                    return reroot(nextPath);\n                } else {\n                    return RootFs(self, path);\n                }\n            });\n        });\n    }\n\n    exports.toObject = function (path) {\n        var self = this;\n        var list = self.listTree(path || \"\", function (path, stat) {\n            return stat.isFile();\n        });\n        return Q.when(list, function (list) {\n            var tree = {};\n            return Q.all(list.map(function (path) {\n                return Q.when(self.read(path, \"rb\"), function (content) {\n                    tree[path] = content;\n                });\n            })).then(function () {\n                return tree;\n            });\n        });\n    };\n\n    exports.merge = function (fss) {\n        var tree = {};\n        var done;\n        fss.forEach(function (fs) {\n            done = Q.when(done, function () {\n                return fs.listTree(\"\", function (path, stat) {\n                    return stat.isFile();\n                })\n                .then(function (list) {\n                    return Q.all(list.map(function (path) {\n                        return Q.when(fs.read(path, \"rb\"), function (content) {\n                            tree[path] = content;\n                        });\n                    }));\n                });\n            });\n        })\n        return Q.when(done, function () {\n            return MockFs(tree);\n        });\n    };\n\n}","blocks":{"total":115,"seen":82,"missing":33,"percentage":0.7130434782608696}},"hash":"5909370009a071fcd6319bf4f1c214d4"},"/Users/kris/q-io/fs-root.js":{"stats":{"percentage":0.8791208791208791,"lines":[{"lineno":18},{"lineno":44},{"lineno":50},{"lineno":59},{"lineno":64},{"lineno":65},{"lineno":67},{"lineno":75},{"lineno":80},{"lineno":81},{"lineno":83}],"missing":11,"seen":80,"total":91,"coverage":{"18":{"partial":false,"source":"            actual = outer.relativeFromDirectory(outer.ROOT, path);","missing":[{"startCol":12,"endCol":67},{"startCol":21,"endCol":66}]},"44":{"partial":false,"source":"                return Q.reject(\"Can't find: \" + JSON.stringify(path));","missing":[{"startCol":16,"endCol":71},{"startCol":23,"endCol":70},{"startCol":32,"endCol":69},{"startCol":49,"endCol":69}]},"50":{"partial":false,"source":"        return outer.ROOT;","missing":[{"startCol":8,"endCol":26}]},"59":{"partial":false,"source":"            return Q.reject(\"Can't list \" + JSON.stringify(path));","missing":[{"startCol":12,"endCol":66},{"startCol":19,"endCol":65},{"startCol":28,"endCol":64},{"startCol":44,"endCol":64}]},"64":{"partial":false,"source":"        return Q.when(attenuate(path), function (path) {","missing":[{},{"startCol":22,"endCol":37}]},"65":{"partial":false,"source":"            return outer.open(path.outer, flags, charset);","missing":[{},{"startCol":19,"endCol":57},{"startCol":12,"endCol":58}]},"66":{"partial":false,"source":"        }).then(null, function (reason) {","missing":[{}]},"67":{"partial":false,"source":"            return Q.reject(\"Can't open \" + JSON.stringify(path));","missing":[{},{"startCol":12,"endCol":66},{"startCol":44,"endCol":64},{"startCol":28,"endCol":64},{"startCol":19,"endCol":65}]},"68":{"partial":false,"source":"        });","missing":[{}]},"75":{"partial":false,"source":"            return Q.reject(\"Can't stat \" + JSON.stringify(path));","missing":[{"startCol":12,"endCol":66},{"startCol":19,"endCol":65},{"startCol":28,"endCol":64},{"startCol":44,"endCol":64}]},"80":{"partial":false,"source":"        return Q.when(attenuate(path), function (path) {","missing":[{"startCol":22,"endCol":37},{}]},"81":{"partial":false,"source":"            return path.inner;","missing":[{},{"startCol":12,"endCol":30}]},"82":{"partial":false,"source":"        }).then(null, function (reason) {","missing":[{}]},"83":{"partial":false,"source":"            return Q.reject(\"Can't find canonical of \" + JSON.stringify(path));","missing":[{},{"startCol":57,"endCol":77},{"startCol":12,"endCol":79},{"startCol":19,"endCol":78},{"startCol":28,"endCol":77}]},"84":{"partial":false,"source":"        });","missing":[{}]}},"source":"var Q = require(\"q\");\nvar BOOT = require(\"./fs-boot\");\nvar COMMON = require(\"./fs-common\");\n\nmodule.exports = RootFs;\n\nfunction RootFs(outer, root) {\n    var inner = Object.create(BOOT);\n\n    function attenuate(path) {\n\n        // the machinations of projecting a path inside a\n        // subroot\n        var actual;\n        // if it's absolute, we want the path relative to\n        // the root of the inner file system\n        if (outer.isAbsolute(path)) {\n            actual = outer.relativeFromDirectory(outer.ROOT, path);\n        } else {\n            actual = path;\n        }\n        // we join the path onto the root of the inner file\n        // system so that parent references from the root\n        // return to the root, emulating standard unix\n        // behavior\n        actual = outer.join(outer.ROOT, actual);\n        // then we reconstruct the path relative to the\n        // inner root\n        actual = outer.relativeFromDirectory(outer.ROOT, actual);\n        // and rejoin it on the outer root\n        actual = outer.join(root, actual);\n        // and find the corresponding real path\n        actual = outer.canonical(actual);\n        return Q.when(actual, function (actual) {\n            // and verify that the outer canonical path is\n            // actually inside the inner canonical path, to\n            // prevent break-outs\n            if (outer.contains(root, actual)) {\n                return {\n                    \"inner\": outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),\n                    \"outer\": actual\n                };\n            } else {\n                return Q.reject(\"Can't find: \" + JSON.stringify(path));\n            }\n        });\n    }\n\n    function workingDirectory() {\n        return outer.ROOT;\n    }\n\n    COMMON.update(inner, workingDirectory);\n\n    inner.list = function (path) {\n        return Q.when(attenuate(path), function (path) {\n            return outer.list(path.outer);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't list \" + JSON.stringify(path));\n        });\n    };\n\n    inner.open = function (path, flags, charset) {\n        return Q.when(attenuate(path), function (path) {\n            return outer.open(path.outer, flags, charset);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't open \" + JSON.stringify(path));\n        });\n    };\n\n    inner.stat = function (path) {\n        return Q.when(attenuate(path), function (path) {\n            return outer.stat(path.outer);\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't stat \" + JSON.stringify(path));\n        });\n    };\n\n    inner.canonical = function (path) {\n        return Q.when(attenuate(path), function (path) {\n            return path.inner;\n        }).then(null, function (reason) {\n            return Q.reject(\"Can't find canonical of \" + JSON.stringify(path));\n        });\n    };\n\n    return Q.when(outer.canonical(root), function (_root) {\n        root = _root;\n        return inner;\n    });\n}","blocks":{"total":21,"seen":10,"missing":11,"percentage":0.47619047619047616}},"hash":"0f5b78a15cb9d4d170bc48f1df919a3a"},"/Users/kris/q-io/fs-mock.js":{"stats":{"percentage":0.9055441478439425,"lines":[{"lineno":60},{"lineno":74},{"lineno":81},{"lineno":95},{"lineno":102},{"lineno":106},{"lineno":132},{"lineno":135},{"lineno":138},{"lineno":152},{"lineno":155},{"lineno":169},{"lineno":172},{"lineno":175},{"lineno":195},{"lineno":208},{"lineno":214},{"lineno":216},{"lineno":217},{"lineno":230},{"lineno":231},{"lineno":238},{"lineno":239},{"lineno":240},{"lineno":241},{"lineno":246},{"lineno":247},{"lineno":248},{"lineno":249},{"lineno":265},{"lineno":267},{"lineno":280},{"lineno":316},{"lineno":329},{"lineno":337},{"lineno":338},{"lineno":339},{"lineno":341},{"lineno":348},{"lineno":360},{"lineno":368},{"lineno":388},{"lineno":392},{"lineno":443},{"lineno":449},{"lineno":471}],"missing":46,"seen":441,"total":487,"coverage":{"60":{"partial":false,"source":"            new Error(\"Can't list non-directory: \" + JSON.stringify(path));","missing":[{"startCol":12,"endCol":75},{"startCol":22,"endCol":73},{"startCol":53,"endCol":73}]},"74":{"partial":false,"source":"            throw new Error(\"Can't find \" + path + \" because \" + directory + \" is not a directory\");","missing":[{"startCol":12,"endCol":100},{"startCol":28,"endCol":48}]},"81":{"partial":false,"source":"            options = options || {};","missing":[{"startCol":12,"endCol":36},{"startCol":22,"endCol":35}]},"95":{"partial":false,"source":"                throw new Error(\"Can't write non-file \" + path);","missing":[{"startCol":16,"endCol":64},{"startCol":32,"endCol":62}]},"102":{"partial":false,"source":"                throw new Error(\"Can't read non-existant \" + path);","missing":[{"startCol":16,"endCol":67},{"startCol":32,"endCol":65}]},"106":{"partial":false,"source":"                throw new Error(\"Can't read non-file \" + path);","missing":[{"startCol":16,"endCol":63},{"startCol":32,"endCol":61}]},"132":{"partial":false,"source":"            throw new Error(\"Can't remove file from non-directory: \" + path);","missing":[{"startCol":12,"endCol":77},{"startCol":28,"endCol":75}]},"135":{"partial":false,"source":"            throw new Error(\"Can't remove non-existant file: \" + path);","missing":[{"startCol":12,"endCol":71},{"startCol":28,"endCol":69}]},"138":{"partial":false,"source":"            throw new Error(\"Can't remove directory. Use removeDirectory: \" + path);","missing":[{"startCol":12,"endCol":84},{"startCol":28,"endCol":82}]},"152":{"partial":false,"source":"            throw new Error(\"Can't make directory in non-directory: \" + path);","missing":[{"startCol":12,"endCol":78},{"startCol":28,"endCol":76}]},"155":{"partial":false,"source":"            throw new Error(\"Can't make directory. Entry exists: \" + path);","missing":[{"startCol":12,"endCol":75},{"startCol":28,"endCol":73}]},"169":{"partial":false,"source":"            throw new Error(\"Can't remove directory from non-directory: \" + path);","missing":[{"startCol":12,"endCol":82},{"startCol":28,"endCol":80}]},"172":{"partial":false,"source":"            throw new Error(\"Can't remove non-existant directory: \" + path);","missing":[{"startCol":12,"endCol":76},{"startCol":28,"endCol":74}]},"175":{"partial":false,"source":"            throw new Error(\"Can't remove non-directory: \" + path);","missing":[{"startCol":12,"endCol":67},{"startCol":28,"endCol":65}]},"195":{"partial":false,"source":"            throw new Error(\"Path is not symbolic link: \" + JSON.stringify(path));","missing":[{"startCol":12,"endCol":82},{"startCol":28,"endCol":80},{"startCol":60,"endCol":80}]},"208":{"partial":false,"source":"            throw new Error(\"Can't link non-file: \" + source);","missing":[{"startCol":12,"endCol":62},{"startCol":28,"endCol":60}]},"214":{"partial":false,"source":"            throw new Error(\"Can't create link in non-directory: \" + target);","missing":[{"startCol":12,"endCol":77},{"startCol":28,"endCol":75}]},"216":{"partial":true,"source":"        if (targetNode._entries[base] && targetNode._entries[base].isDirectory()) {","missing":[{"startCol":41,"endCol":80}]},"217":{"partial":false,"source":"            throw new Error(\"Can't overwrite existing directory with hard link: \" + target);","missing":[{"startCol":12,"endCol":92},{"startCol":28,"endCol":90}]},"230":{"partial":true,"source":"        if (node._entries[base] && node._entries[base].isDirectory()) {","missing":[{"startCol":35,"endCol":68}]},"231":{"partial":false,"source":"            throw new Error(\"Can't overwrite existing directory with symbolic link: \" + target);","missing":[{"startCol":12,"endCol":96},{"startCol":28,"endCol":94}]},"238":{"partial":false,"source":"    var self = this;","missing":[{"startCol":4,"endCol":20}]},"239":{"partial":false,"source":"    return Q.fcall(function () {","missing":[{}]},"240":{"partial":false,"source":"        path = self.absolute(path);","missing":[{},{"startCol":8,"endCol":35},{"startCol":15,"endCol":34}]},"241":{"partial":false,"source":"        self._root._walk(path)._follow(path)._owner = owner;","missing":[{"startCol":8,"endCol":60},{"startCol":24,"endCol":30},{"startCol":38,"endCol":44},{}]},"242":{"partial":false,"source":"    });","missing":[{}]},"246":{"partial":false,"source":"    var self = this;","missing":[{"startCol":4,"endCol":20}]},"247":{"partial":false,"source":"    return Q.fcall(function () {","missing":[{}]},"248":{"partial":false,"source":"        path = self.absolute(path);","missing":[{"startCol":8,"endCol":35},{},{"startCol":15,"endCol":34}]},"249":{"partial":false,"source":"        self._root._walk(path)._follow(path)._mode = mode;","missing":[{"startCol":8,"endCol":58},{"startCol":38,"endCol":44},{},{"startCol":24,"endCol":30}]},"250":{"partial":false,"source":"    });","missing":[{}]},"265":{"partial":true,"source":"        if (targetDirectoryNode._entries[targetName] && targetDirectoryNode._entires[targetName].isDirectory()) {","missing":[{"startCol":56,"endCol":110}]},"267":{"partial":false,"source":"            targetDirectoryNode = targetDirectoryNode._entries[targetName]._follow(target);","missing":[{"startCol":12,"endCol":91},{"startCol":34,"endCol":90}]},"280":{"partial":false,"source":"            throw new Error(\"Can't read non-symbolic link: \" + path);","missing":[{"startCol":12,"endCol":69},{"startCol":28,"endCol":67}]},"316":{"partial":false,"source":"        throw new Error(\"FS required argument\");","missing":[{"startCol":8,"endCol":48}]},"329":{"partial":false,"source":"        return this._walkParts(parts, make, via || this._fs.ROOT);","missing":[{"startCol":8,"endCol":66},{"startCol":15,"endCol":65},{"startCol":44,"endCol":64}]},"337":{"partial":false,"source":"        var part = parts.shift();","missing":[{"startCol":8,"endCol":33},{"startCol":19,"endCol":32}]},"338":{"partial":false,"source":"        if (part === \"\") {","missing":[{"startCol":12,"endCol":23}]},"339":{"partial":false,"source":"            return this._walkParts(parts, make, this._fs.join(via, part));","missing":[{"startCol":12,"endCol":74},{"startCol":19,"endCol":73},{"startCol":48,"endCol":72}]},"341":{"partial":false,"source":"            throw new Error(\"Can't find \" + JSON.stringify(this._fs.resolve(part, this._fs.join(parts))) + \" via \" + JSON.stringify(via));","missing":[{"startCol":12,"endCol":138},{"startCol":28,"endCol":104},{"startCol":44,"endCol":104},{"startCol":59,"endCol":103},{"startCol":82,"endCol":102},{"startCol":117,"endCol":136}]},"348":{"partial":false,"source":"        throw new Error(\"Path must be absolute for _canonical: \" + path);","missing":[{"startCol":8,"endCol":73},{"startCol":24,"endCol":71}]},"360":{"partial":false,"source":"    return this._fs.join(via, this._fs.join(parts));","missing":[{"startCol":4,"endCol":52},{"startCol":11,"endCol":51},{"startCol":30,"endCol":50}]},"368":{"partial":false,"source":"    this._modified = new Date();","missing":[{"startCol":4,"endCol":32}]},"388":{"partial":false,"source":"    return this._accessed;","missing":[{"startCol":4,"endCol":26}]},"392":{"partial":false,"source":"    return this._modified;","missing":[{"startCol":4,"endCol":26}]},"443":{"partial":false,"source":"        return via;","missing":[{"startCol":8,"endCol":19}]},"449":{"partial":false,"source":"        return this._fs.join(via, part, this._fs.join(parts));","missing":[{"startCol":8,"endCol":62},{"startCol":15,"endCol":61},{"startCol":40,"endCol":60}]},"471":{"partial":false,"source":"        throw new Error(\"Can't follow symbolic link cycle at \" + JSON.stringify(via));","missing":[{"startCol":8,"endCol":86},{"startCol":24,"endCol":84},{"startCol":65,"endCol":84}]}},"source":"var Q = require(\"q\");\nvar Boot = require(\"./fs-boot\");\nvar Common = require(\"./fs-common\");\nvar BufferStream = require(\"./buffer-stream\");\nvar Reader = require(\"./reader\");\nvar Set = require(\"collections/set\");\n\nmodule.exports = MockFs;\n\nfunction MockFs(files) {\n    if (!(this instanceof MockFs)) {\n        return new MockFs(files);\n    }\n    this._root = new DirectoryNode(this, \"/\");\n\n    function init() {\n        // construct a file tree\n    }\n\n    Common.update(this, function () {\n        return workingDirectory;\n    });\n\n    var workingDirectory = this.ROOT;\n    if (files) {\n        this._init(files);\n    }\n}\n\nMockFs.prototype = Object.create(Boot);\n\nMockFs.prototype._init = function (files, tree) {\n    tree = tree || this.ROOT;\n    Object.keys(files).forEach(function (path) {\n        var content = files[path];\n        path = this.join(tree, path);\n        var directory = this.directory(path);\n        var base = this.base(path);\n        var directoryNode = this._root._walk(directory, true);\n        var fileNode = new FileNode(this);\n        if (!(content instanceof Buffer)) {\n            if (typeof content === \"object\") {\n                this._init(content, path);\n                return;\n            } else {\n                content = new Buffer(String(content), \"utf-8\");\n            }\n        }\n        directoryNode._entries[base] = fileNode;\n        fileNode._chunks = [content];\n    }, this);\n};\n\nMockFs.prototype.list = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var node = self._root._walk(path)._follow(path);\n        if (!node.isDirectory()) {\n            new Error(\"Can't list non-directory: \" + JSON.stringify(path));\n        }\n        return Object.keys(node._entries).sort();\n    });\n};\n\nMockFs.prototype.open = function (path, flags, charset, options) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var base = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't find \" + path + \" because \" + directory + \" is not a directory\");\n        }\n        if (typeof flags == \"object\") {\n            options = flags;\n            flags = options.flags;\n            charset = options.charset;\n        } else {\n            options = options || {};\n        }\n        flags = flags || \"r\";\n        var binary = flags.indexOf(\"b\") >= 0;\n        var write = flags.indexOf(\"w\") >= 0;\n        if (!binary) {\n            charset = charset || \"utf-8\";\n        }\n        if (write) {\n            if (!node._entries[base]) {\n                node._entries[base] = new FileNode(this);\n            }\n            var fileNode = node._entries[base]._follow(path);\n            if (!fileNode.isFile()) {\n                throw new Error(\"Can't write non-file \" + path);\n            }\n            fileNode._lastModified = new Date();\n            fileNode._lastAccessed = new Date();\n            return new BufferStream(fileNode._chunks, charset);\n        } else { // read\n            if (!node._entries[base]) {\n                throw new Error(\"Can't read non-existant \" + path);\n            }\n            var fileNode = node._entries[base]._follow(path);\n            if (!fileNode.isFile()) {\n                throw new Error(\"Can't read non-file \" + path);\n            }\n            fileNode._lastAccessed = new Date();\n            if (\"begin\" in options && \"end\" in options) {\n                return new BufferStream(\n                    [\n                        Reader.join(fileNode._chunks)\n                        .slice(options.begin, options.end)\n                    ],\n                    charset\n                );\n            } else {\n                return new BufferStream(fileNode._chunks, charset);\n            }\n        }\n    });\n};\n\nMockFs.prototype.remove = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't remove file from non-directory: \" + path);\n        }\n        if (!node._entries[name]) {\n            throw new Error(\"Can't remove non-existant file: \" + path);\n        }\n        if (node._entries[name].isDirectory()) {\n            throw new Error(\"Can't remove directory. Use removeDirectory: \" + path);\n        }\n        delete node._entries[name];\n    });\n};\n\nMockFs.prototype.makeDirectory = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't make directory in non-directory: \" + path);\n        }\n        if (node._entries[name]) {\n            throw new Error(\"Can't make directory. Entry exists: \" + path);\n        }\n        node._entries[name] = new DirectoryNode(self);\n    });\n};\n\nMockFs.prototype.removeDirectory = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var directory = self.directory(path);\n        var name = self.base(path);\n        var node = self._root._walk(directory);\n        if (!node.isDirectory()) {\n            throw new Error(\"Can't remove directory from non-directory: \" + path);\n        }\n        if (!node._entries[name]) {\n            throw new Error(\"Can't remove non-existant directory: \" + path);\n        }\n        if (!node._entries[name].isDirectory()) {\n            throw new Error(\"Can't remove non-directory: \" + path);\n        }\n        delete node._entries[name];\n    });\n};\n\nMockFs.prototype.stat = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        return self._root._walk(path)._follow(path);\n    });\n};\n\nMockFs.prototype.statLink = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var node = self._root._walk(path);\n        if (!node.isSymbolicLink()) {\n            throw new Error(\"Path is not symbolic link: \" + JSON.stringify(path));\n        }\n        return node;\n    });\n};\n\nMockFs.prototype.link = function (source, target) {\n    var self = this;\n    return Q.fcall(function () {\n        source = self.absolute(source);\n        target = self.absolute(target);\n        var sourceNode = self._root._walk(source)._follow(source);\n        if (!sourceNode.isFile()) {\n            throw new Error(\"Can't link non-file: \" + source);\n        }\n        var directory = self.directory(target);\n        var base = self.base(target);\n        var targetNode = self._root._walk(directory)._follow(directory);\n        if (!targetNode.isDirectory()) {\n            throw new Error(\"Can't create link in non-directory: \" + target);\n        }\n        if (targetNode._entries[base] && targetNode._entries[base].isDirectory()) {\n            throw new Error(\"Can't overwrite existing directory with hard link: \" + target);\n        }\n        targetNode._entries[base] = sourceNode;\n    });\n};\n\nMockFs.prototype.symbolicLink = function (target, relative, type) {\n    var self = this;\n    return Q.fcall(function () {\n        target = self.absolute(target);\n        var directory = self.directory(target);\n        var base = self.base(target);\n        var node = self._root._walk(directory);\n        if (node._entries[base] && node._entries[base].isDirectory()) {\n            throw new Error(\"Can't overwrite existing directory with symbolic link: \" + target);\n        }\n        node._entries[base] = new LinkNode(self, relative);\n    });\n};\n\nMockFs.prototype.chown = function (path, owner) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        self._root._walk(path)._follow(path)._owner = owner;\n    });\n};\n\nMockFs.prototype.chmod = function (path, mode) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        self._root._walk(path)._follow(path)._mode = mode;\n    });\n};\n\nMockFs.prototype.move = function (source, target) {\n    var self = this;\n    return Q.fcall(function () {\n        source = self.absolute(source);\n        target = self.absolute(target);\n        var sourceDirectory = self.directory(source);\n        var sourceDirectoryNode = self._root._walk(sourceDirectory)._follow(sourceDirectory);\n        var sourceName = self.base(source);\n        var sourceNode = sourceDirectoryNode._entries[sourceName]; // not followed\n        var targetDirectory = self.directory(target);\n        var targetDirectoryNode = self._root._walk(targetDirectory)._follow(targetDirectory);\n        var targetName = self.base(target);\n        if (targetDirectoryNode._entries[targetName] && targetDirectoryNode._entires[targetName].isDirectory()) {\n            // move the node into the directory\n            targetDirectoryNode = targetDirectoryNode._entries[targetName]._follow(target);\n        }\n        targetDirectoryNode._entries[targetName] = sourceNode;\n        delete sourceDirectoryNode._entries[sourceName];\n    });\n};\n\nMockFs.prototype.readLink = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        var node = self._root._walk(path);\n        if (!self.isSymbolicLink()) {\n            throw new Error(\"Can't read non-symbolic link: \" + path);\n        }\n        return node._link;\n    });\n};\n\nMockFs.prototype.canonical = function (path) {\n    var self = this;\n    return Q.fcall(function () {\n        path = self.absolute(path);\n        return self._root._canonical(path);\n    });\n};\n\nMockFs.mock = mock;\nfunction mock(fs, root) {\n    return Q.when(fs.listTree(root), function (list) {\n        var tree = {};\n        return Q.all(list.map(function (path) {\n            var actual = fs.join(root, path);\n            var relative = fs.relativeFromDirectory(root, actual);\n            return Q.when(fs.stat(actual), function (stat) {\n                if (stat.isFile()) {\n                    return Q.when(fs.read(path, \"rb\"), function (content) {\n                        tree[relative] = content;\n                    });\n                }\n            });\n        })).then(function () {\n            return MockFs(tree);\n        });\n    });\n}\n\nfunction Node(fs) {\n    if (!fs)\n        throw new Error(\"FS required argument\");\n    this._fs = fs;\n    this._accessed = this._modified = new Date();\n    this._mode = parseInt(\"0644\", 8);\n    this._owner = null;\n}\n\nNode.prototype._walk = function (path, make, via) {\n    var parts = this._fs.split(path);\n    if (this._fs.isAbsolute(path)) {\n        parts.shift();\n        return this._fs._root._walkParts(parts, make, this._fs.ROOT);\n    } else {\n        return this._walkParts(parts, make, via || this._fs.ROOT);\n    }\n};\n\nNode.prototype._walkParts = function (parts, make, via) {\n    if (parts.length === 0) {\n        return this;\n    } else {\n        var part = parts.shift();\n        if (part === \"\") {\n            return this._walkParts(parts, make, this._fs.join(via, part));\n        } else {\n            throw new Error(\"Can't find \" + JSON.stringify(this._fs.resolve(part, this._fs.join(parts))) + \" via \" + JSON.stringify(via));\n        }\n    }\n};\n\nNode.prototype._canonical = function (path) {\n    if (!this._fs.isAbsolute(path)) {\n        throw new Error(\"Path must be absolute for _canonical: \" + path);\n    }\n    var parts = this._fs.split(path);\n    parts.shift();\n    var via = this._fs.ROOT;\n    return via + this._fs._root._canonicalParts(parts, via);\n};\n\nNode.prototype._canonicalParts = function (parts, via) {\n    if (parts.length === 0) {\n        return via;\n    }\n    return this._fs.join(via, this._fs.join(parts));\n};\n\nNode.prototype._follow = function () {\n    return this;\n};\n\nNode.prototype._touch = function () {\n    this._modified = new Date();\n};\n\nvar stats = [\n    \"isDirectory\",\n    \"isFile\",\n    \"isBlockDevice\",\n    \"isCharacterDevice\",\n    \"isSymbolicLink\",\n    \"isFIFO\",\n    \"isSocket\"\n];\n\nstats.forEach(function (name) {\n    Node.prototype[name] = function () {\n        return false;\n    };\n});\n\nNode.prototype.lastAccessed = function () {\n    return this._accessed;\n};\n\nNode.prototype.lastModified = function () {\n    return this._modified;\n};\n\nfunction FileNode(fs) {\n    Node.call(this, fs);\n    this._chunks = [];\n}\n\nFileNode.prototype = Object.create(Node.prototype);\n\nFileNode.prototype.isFile = function () {\n    return true;\n};\n\nfunction DirectoryNode(fs) {\n    Node.call(this, fs);\n    this._entries = Object.create(null);\n    this._mode = parseInt(\"0755\", 8);\n}\n\nDirectoryNode.prototype = Object.create(Node.prototype);\n\nDirectoryNode.prototype.isDirectory = function () {\n    return true;\n};\n\nDirectoryNode.prototype._walkParts = function (parts, make, via) {\n    via = via || this._fs.ROOT;\n    if (parts.length === 0) {\n        return this;\n    }\n    var part = parts.shift();\n    if (part === \"\") {\n        return this._walkParts(parts, make, this._fs.join(via, part));\n    }\n    if (!this._entries[part]) {\n        if (make) {\n            this._entries[part] = new DirectoryNode(this._fs);\n        } else {\n            throw new Error(\"Can't find \" + JSON.stringify(this._fs.join(parts)) + \" via \" + JSON.stringify(via));\n        }\n    }\n    return this._entries[part]._walkParts(parts, make, this._fs.join(via, part));\n};\n\nDirectoryNode.prototype._canonicalParts = function (parts, via) {\n    if (parts.length === 0) {\n        return via;\n    }\n    var part = parts.shift();\n    if (part === \"\") {\n        return via;\n    }\n    if (via === this._fs.ROOT) {\n        via = \"\";\n    }\n    if (!this._entries[part]) {\n        return this._fs.join(via, part, this._fs.join(parts));\n    }\n    return this._entries[part]._canonicalParts(\n        parts,\n        this._fs.join(via, part)\n    );\n};\n\nfunction LinkNode(fs, link) {\n    Node.call(this, fs);\n    this._link = link;\n}\n\nLinkNode.prototype = Object.create(Node.prototype);\n\nLinkNode.prototype.isSymbolicLink = function () {\n    return true;\n};\n\nLinkNode.prototype._follow = function (via, memo) {\n    memo = memo || Set();\n    if (memo.has(this)) {\n        throw new Error(\"Can't follow symbolic link cycle at \" + JSON.stringify(via));\n    }\n    memo.add(this);\n    var link = this._fs.join(via, \"..\", this._link);\n    return this._walk(link, null, \"<link>\")._follow(link, memo);\n};\n\nLinkNode.prototype._canonicalParts = function (parts, via) {\n    return this._fs.relativeFromDirectory(this._fs.ROOT,\n        this._fs._root._canonical(\n            this._fs.absolute(this._fs.join(via, \"..\", this._link))\n        )\n    );\n};\n\n// cycle breaking\nvar FS = require(\"./fs\");","blocks":{"total":113,"seen":75,"missing":38,"percentage":0.6637168141592921}},"hash":"b677abd706df5d4c2a0d47bc9b739d1a"},"/Users/kris/q-io/buffer-stream.js":{"stats":{"percentage":0.8947368421052632,"lines":[{"lineno":7},{"lineno":10},{"lineno":12},{"lineno":42},{"lineno":55},{"lineno":56}],"missing":6,"seen":51,"total":57,"coverage":{"7":{"partial":false,"source":"        return new BufferStream(chunks, charset);","missing":[{"startCol":8,"endCol":49}]},"10":{"partial":false,"source":"        chunks = [];","missing":[{"startCol":8,"endCol":20}]},"12":{"partial":false,"source":"        chunks = [chunks];","missing":[{"startCol":8,"endCol":26}]},"42":{"partial":false,"source":"            throw new Error(\"Can't write strings to buffer stream without a charset: \" + chunk);","missing":[{"startCol":12,"endCol":96},{"startCol":28,"endCol":94}]},"55":{"partial":false,"source":"    this._close.resolve();","missing":[{"startCol":4,"endCol":25}]},"56":{"partial":false,"source":"    return Q.resolve();","missing":[{"startCol":4,"endCol":23},{"startCol":11,"endCol":22}]}},"source":"var Q = require(\"q\");\nvar Reader = require(\"./reader\");\n\nmodule.exports = BufferStream;\nfunction BufferStream(chunks, charset) {\n    if (!(this instanceof BufferStream)) {\n        return new BufferStream(chunks, charset);\n    }\n    if (!chunks) {\n        chunks = [];\n    } else if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n    }\n    this._charset = charset;\n    this._chunks = chunks;\n    this._close = Q.defer();\n    this.closed = this._close.promise;\n}\n\nBufferStream.prototype.forEach = function (write, thisp) {\n    var self = this;\n    var chunks = self._chunks;\n    return Q.fcall(function () {\n        chunks.splice(0, chunks.length).forEach(write, thisp);\n    });\n};\n\nBufferStream.prototype.read = function () {\n    var result;\n    result = Reader.join(this._chunks);\n    if (this._charset) {\n        result = result.toString(this._charset);\n    }\n    return Q.resolve(result);\n};\n\nBufferStream.prototype.write = function (chunk) {\n    if (this._charset) {\n        chunk = new Buffer(String(chunk), this._charset);\n    } else {\n        if (!(chunk instanceof Buffer)) {\n            throw new Error(\"Can't write strings to buffer stream without a charset: \" + chunk);\n        }\n    }\n    this._chunks.push(chunk);\n    return Q.resolve();\n};\n\nBufferStream.prototype.close = function () {\n    this._close.resolve();\n    return Q.resolve();\n};\n\nBufferStream.prototype.destroy = function () {\n    this._close.resolve();\n    return Q.resolve();\n};","blocks":{"total":14,"seen":9,"missing":5,"percentage":0.6428571428571429}},"hash":"cefdc526b6f9a887b2e346b5864ae9f6"},"/Users/kris/q-io/spec/fs/mock/copy-tree-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":55,"total":55,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\n\ndescribe(\"copyTree\", function () {\n    it(\"should copy a tree\", function () {\n\n        var mock = Mock({\n            \"a/b\": {\n                \"c\": {\n                    \"d\": 66,\n                    \"e\": 99\n                }\n            }\n        });\n\n        return Q.fcall(function () {\n            return mock.copyTree(\"a/b\", \"a/f\");\n        })\n        .then(function () {\n            return Q.all([\n                mock.isDirectory(\"a/f\"),\n                mock.exists(\"a/f/c\"),\n                mock.isFile(\"a/f/c/d\"),\n                mock.read(\"a/f/c/e\")\n            ])\n        })\n        .then(function (existence) {\n            expect(existence.every(Boolean)).toBe(true);\n        })\n\n        .then(function () {\n            return mock.listTree();\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"a\",\n                \"a/b\",\n                \"a/b/c\",\n                \"a/b/c/d\",\n                \"a/b/c/e\",\n                \"a/f\",\n                \"a/f/c\",\n                \"a/f/c/d\",\n                \"a/f/c/e\"\n            ]);\n        })\n\n    });\n\n});","blocks":{"total":7,"seen":7,"missing":0,"percentage":1}},"hash":"0e588a54cf423c2810615b5de87d66e6"},"/Users/kris/q-io/spec/fs/mock/link-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":66,"total":66,"coverage":{},"source":"require(\"../../lib/jasmine-promise\");\nvar MockFs = require(\"../../../fs-mock\");\n\ndescribe(\"link\", function () {\n    it(\"should\", function () {\n        var mock = MockFs();\n\n        // make some content\n        return mock.makeTree(\"a/b\")\n        .then(function () {\n            return mock.write(\"a/b/c.txt\", \"Hello, World!\")\n        })\n\n        // verify content\n        .then(function () {\n            return mock.read(\"a/b/c.txt\")\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        })\n\n        // link it\n        .then(function () {\n            return mock.link(\"a/b/c.txt\", \"a/b/d.txt\")\n        })\n\n        // should be non-destructive\n        .then(function () {\n            return mock.read(\"a/b/c.txt\")\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        })\n\n        // should be listed\n        .then(function () {\n            return mock.listTree()\n        })\n        .then(function (content) {\n            expect(content).toEqual([\n                \".\",\n                \"a\",\n                \"a/b\",\n                \"a/b/c.txt\",\n                \"a/b/d.txt\"\n            ])\n        })\n\n        // should be identified as a file\n        .then(function () {\n            return mock.isFile(\"a/b/d.txt\");\n        })\n        .then(function (isFile) {\n            expect(isFile).toBe(true);\n        })\n\n        // should have the same content\n        .then(function () {\n            return mock.read(\"a/b/d.txt\");\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        });\n\n    });\n});","blocks":{"total":14,"seen":14,"missing":0,"percentage":1}},"hash":"dfd1220232183ac922f40682eb85cdaa"},"/Users/kris/q-io/spec/fs/mock/make-tree-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":47,"total":47,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\n\ndescribe(\"makeTree\", function () {\n    it(\"should make a branch of a tree\", function () {\n\n        var mock = Mock({\n            \"a\": {}\n        });\n\n        return Q.fcall(function () {\n            return mock.makeTree(\"a/b/c\");\n        })\n\n        .then(function () {\n            return mock.listTree();\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"a\",\n                \"a/b\",\n                \"a/b/c\"\n            ]);\n        })\n\n        .then(function () {\n            return mock.exists(\"a/b/c\")\n        })\n        .then(function (exists) {\n            expect(exists).toBe(true);\n        })\n\n        .then(function () {\n            return mock.isDirectory(\"a/b/c\")\n        })\n        .then(function (isDirectory) {\n            expect(isDirectory).toBe(true);\n        })\n\n    });\n\n});","blocks":{"total":9,"seen":9,"missing":0,"percentage":1}},"hash":"904f91a01af1fb9861e59c4837d93eea"},"/Users/kris/q-io/spec/fs/mock/merge-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":65,"total":65,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\n\ndescribe(\"makeTree\", function () {\n    it(\"should make a branch of a tree\", function () {\n\n        var merged = FS.merge([\n            Mock({\n                \"a\": 10,\n                \"b\": 20,\n                \"1/2/3\": \"123\"\n            }),\n            Mock({\n                \"a\": 20,\n                \"c\": 30\n            }),\n            Mock({\n                \"a\": 30,\n                \"d\": 40\n            }),\n        ])\n\n        return merged.then(function (merged) {\n\n            return Q.fcall(function () {\n                return merged.listTree();\n            })\n            .then(function (list) {\n                expect(list.sort()).toEqual([\n                    \".\",\n                    \"1\",\n                    \"1/2\",\n                    \"1/2/3\",\n                    \"a\",\n                    \"b\",\n                    \"c\",\n                    \"d\",\n                ]);\n            })\n\n            // overridden by a previous tree\n            .then(function () {\n                return merged.read(\"a\");\n            })\n            .then(function (a) {\n                expect(a).toBe(\"30\");\n            })\n\n            // not overridden\n            .then(function () {\n                return merged.read(\"b\");\n            })\n            .then(function (a) {\n                expect(a).toBe(\"20\");\n            })\n\n        })\n\n    });\n\n});","blocks":{"total":9,"seen":9,"missing":0,"percentage":1}},"hash":"782861548d3ca57be49212fe5b2cb199"},"/Users/kris/q-io/spec/fs/mock/move-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":58,"total":58,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"move\", function () {\n    it(\"should move\", function () {\n\n        return FS.mock(FS, FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            // initial list\n            return Q.fcall(function () {\n                return mock.listTree()\n            })\n            .then(function (list) {\n                expect(list).toEqual([\n                    \".\",\n                    \"hello.txt\"\n                ]);\n            })\n\n            // initial content\n            .then(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n\n            // move!\n            .then(function () {\n                return mock.move(\"hello.txt\", \"new-hello.txt\");\n            })\n\n            // list after\n            .then(function () {\n                return mock.listTree();\n            })\n            .then(function (list) {\n                expect(list).toEqual([\n                    \".\",\n                    \"new-hello.txt\"\n                ]);\n            })\n\n            // content after\n            .then(function () {\n                return mock.read(\"new-hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n\n        });\n    });\n});","blocks":{"total":12,"seen":12,"missing":0,"percentage":1}},"hash":"b0e2282ee10099a4dc389b8db946ad5b"},"/Users/kris/q-io/spec/fs/mock/object-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":19,"total":19,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"toObject\", function () {\n    it(\"should take a snapshot of a tree\", function () {\n\n        return FS.mock(FS, FS.join(__dirname, \"fixture\"))\n        .invoke(\"toObject\")\n        .then(function (tree) {\n\n            expect(tree[\"hello.txt\"].toString(\"utf-8\")).toEqual(\"Hello, World!\\n\");\n            expect(Object.keys(tree)).toEqual([\"hello.txt\"]);\n\n        });\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"b4f26a5632290c77b8e98b1c675da5cb"},"/Users/kris/q-io/spec/fs/mock/range-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":25,"total":25,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\n\ndescribe(\"open range\", function () {\n    it(\"read a partial range of a file\", function () {\n\n        return FS.mock(FS, FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            return mock.read(\"hello.txt\", {\n                begin: 1,\n                end: 3\n            })\n            .then(function (content) {\n                expect(content).toBe(\"el\");\n            })\n\n        });\n\n    });\n});","blocks":{"total":4,"seen":4,"missing":0,"percentage":1}},"hash":"095c9f7e72bb3b8bd19682fdb4eb7034"},"/Users/kris/q-io/spec/fs/mock/read-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":22,"total":22,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"read\", function () {\n    it(\"should read a file from a mock filesystem\", function () {\n\n        return FS.mock(FS, FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            return Q.fcall(function () {\n                return mock.read(\"hello.txt\");\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\\n\");\n            })\n\n        });\n    });\n});","blocks":{"total":5,"seen":5,"missing":0,"percentage":1}},"hash":"f89672e5547beb6bb903f701153d4118"},"/Users/kris/q-io/spec/fs/mock/remove-directory-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":36,"total":36,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"removeDirectory\", function () {\n    it(\"should remove a directory\", function () {\n\n        return FS.mock(FS, FS.join(__dirname))\n        .then(function (mock) {\n\n            // now you see it\n            return Q.fcall(function () {\n                return mock.isDirectory(\"fixture\");\n            })\n            .then(function (isDirectory) {\n                expect(isDirectory).toBe(true);\n            })\n\n            .then(function () {\n                return mock.removeDirectory(\"fixture\");\n            })\n\n            // now you don't\n            .then(function () {\n                return mock.isDirectory(\"fixture\");\n            })\n            .then(function (isDirectory) {\n                expect(isDirectory).toBe(false);\n            })\n\n        });\n\n    });\n});","blocks":{"total":8,"seen":8,"missing":0,"percentage":1}},"hash":"ccba9a6a0b193fbea992de4d916509d7"},"/Users/kris/q-io/spec/fs/mock/remove-tree-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":37,"total":37,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\n\ndescribe(\"removeTree\", function () {\n    it(\"should remove a tree\", function () {\n\n        var mock = Mock({\n            \"a/b\": {\n                \"c\": {\n                    \"d\": 66,\n                    \"e\": 99\n                }\n            }\n        });\n\n        return Q.fcall(function () {\n            return mock.removeTree(\"a/b/c\");\n        })\n\n        .then(function () {\n            return mock.listTree();\n        })\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"a\",\n                \"a/b\"\n            ]);\n        })\n\n    });\n\n});","blocks":{"total":5,"seen":5,"missing":0,"percentage":1}},"hash":"5db2d1d8f1b0ef75e6a108c43085b01f"},"/Users/kris/q-io/spec/fs/mock/root-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":31,"total":31,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\nvar Mock = require(\"../../../fs-mock\");\nvar Root = require(\"../../../fs-root\");\n\ndescribe(\"root\", function () {\n    it(\"should make a filesystem from a subtree of a mock filesystem\", function () {\n\n        var mock = Mock({\n            \"a/b/1\": 10,\n            \"a/b/2\": 20,\n            \"a/b/3\": 30\n        });\n\n        var chroot = Root(mock, \"a/b\");\n\n        return chroot.invoke(\"listTree\")\n        .then(function (list) {\n            expect(list).toEqual([\n                \".\",\n                \"1\",\n                \"2\",\n                \"3\"\n            ]);\n        });\n\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"eea3a69862bc928fb03397376a95f540"},"/Users/kris/q-io/spec/fs/mock/symbolic-link-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":82,"total":82,"coverage":{},"source":"require(\"../../lib/jasmine-promise\");\nvar MockFs = require(\"../../../fs-mock\");\n\ndescribe(\"symbolic link\", function () {\n    it(\"should\", function () {\n        var mock = MockFs();\n\n        // make some content\n        return mock.makeTree(\"a/b\")\n        .then(function () {\n            return mock.write(\"a/b/c.txt\", \"Hello, World!\")\n        })\n\n        // verify content\n        .then(function () {\n            return mock.read(\"a/b/c.txt\")\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        })\n\n        // link it\n        .then(function () {\n            return mock.symbolicCopy(\"/a/b/c.txt\", \"a/b/d.txt\", \"file\")\n        })\n\n        // should have a link\n        .then(function () {\n            return mock.readLink(\"a/b/d.txt\")\n        })\n        .then(function (link) {\n            expect(link).toBe(\"c.txt\");\n        })\n\n        // should have a canonical path\n        .then(function () {\n            return mock.canonical(\"a/b/d.txt\")\n        })\n        .then(function (canonical) {\n            expect(canonical).toBe(\"/a/b/c.txt\");\n        })\n\n        // should be listed\n        .then(function () {\n            return mock.listTree()\n        })\n        .then(function (content) {\n            expect(content).toEqual([\n                \".\",\n                \"a\",\n                \"a/b\",\n                \"a/b/c.txt\",\n                \"a/b/d.txt\"\n            ])\n        })\n\n        // should be non-destructive\n        .then(function () {\n            return mock.read(\"a/b/c.txt\")\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        })\n\n        // should be identified as a file\n        .then(function () {\n            return mock.isSymbolicLink(\"a/b/d.txt\");\n        })\n        .then(function (isSymbolicLink) {\n            expect(isSymbolicLink).toBe(true);\n        })\n\n        // should have the same content\n        .then(function () {\n            return mock.read(\"a/b/d.txt\");\n        })\n        .then(function (content) {\n            expect(content).toBe(\"Hello, World!\");\n        });\n\n    });\n});","blocks":{"total":18,"seen":18,"missing":0,"percentage":1}},"hash":"0b56e6334b132e31430724f80fb8aff4"},"/Users/kris/q-io/spec/fs/mock/write-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":25,"total":25,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../../fs\");\n\ndescribe(\"write\", function () {\n    it(\"should write a file to a mock filesystem\", function () {\n\n        return FS.mock(FS, FS.join(__dirname, \"fixture\"))\n        .then(function (mock) {\n\n            return Q.fcall(function () {\n                return mock.write(\"hello.txt\", \"Goodbye!\\n\");\n            })\n            .then(function () {\n                return mock.isFile(\"hello.txt\");\n            })\n            .then(function (isFile) {\n                expect(isFile).toBe(true);\n            })\n\n        });\n    });\n});","blocks":{"total":6,"seen":6,"missing":0,"percentage":1}},"hash":"a3539e601466a2b890db8533f5a9bbf0"},"/Users/kris/q-io/spec/fs/range-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":22,"total":22,"coverage":{},"source":"\"use strict\";\n\nrequire(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar FS = require(\"../../fs\");\n\ndescribe(\"open range\", function () {\n    it(\"read a partial range of a file\", function () {\n\n        var name = FS.join(module.directory || __dirname, \"range-spec.txt\");\n\n        return FS.open(name, {\n            begin: 1,\n            end: 3\n        })\n        .invoke(\"read\")\n        .then(function (content) {\n            expect(content).toBe(\"23\");\n        })\n\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"56b279f509eb873fc332e9d6a13b5869"},"/Users/kris/q-io/spec/http-apps/cookie-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":50,"total":50,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar Http = require(\"../../http\");\nvar Apps = require(\"../../http-apps\");\n\ndescribe(\"http cookies\", function () {\n\n    var hosts = [\"localhost\", \"127.0.0.1\"];\n\n    hosts.forEach(function (host) {\n        it(\"should work on host\" + host, function () {\n\n            var server = Http.Server(function (request) {\n                return {\n                    status: 200,\n                    headers: {\n                        \"set-cookie\": \"a=10; MaxAge=1\"\n                    },\n                    body: [request.headers.cookie || \"\"]\n                };\n            });\n\n            var request = Apps.Normalize(Apps.CookieJar(Http.request));\n\n            return server.listen(0)\n            .then(function (server) {\n                var address = server.node.address();\n                return request(\"http://\" + host + \":\" + address.port)\n                .get(\"body\")\n                .invoke(\"read\")\n                .invoke(\"toString\", \"utf-8\")\n                .then(function (content) {\n                    expect(content).toEqual(\"\"); // no cookie first time\n                })\n                .then(function () {\n                    return request(\"http://\" + host + \":\" + address.port)\n                    .get(\"body\")\n                    .invoke(\"read\")\n                    .invoke(\"toString\", \"utf-8\")\n                })\n                .then(function (content) {\n                    expect(content).toEqual(\"a=10\"); // cookie set second time\n                })\n            })\n            .timeout(1000)\n            .finally(server.stop)\n        });\n    });\n\n});","blocks":{"total":8,"seen":8,"missing":0,"percentage":1}},"hash":"5e750c3836f40ec27dc74aa9a2de0dbb"},"/Users/kris/q-io/http.js":{"stats":{"percentage":0.9318801089918256,"lines":[{"lineno":34},{"lineno":43},{"lineno":48},{"lineno":61},{"lineno":81},{"lineno":94},{"lineno":114},{"lineno":129},{"lineno":147},{"lineno":153},{"lineno":194},{"lineno":242},{"lineno":245},{"lineno":248},{"lineno":271},{"lineno":279},{"lineno":288},{"lineno":289},{"lineno":294},{"lineno":301},{"lineno":302},{"lineno":303},{"lineno":335},{"lineno":336},{"lineno":337}],"missing":25,"seen":342,"total":367,"coverage":{"34":{"partial":false,"source":"                closed.reject(error);","missing":[{"startCol":16,"endCol":36}]},"43":{"partial":false,"source":"                    return;","missing":[{"startCol":20,"endCol":27}]},"48":{"partial":false,"source":"                    Q.when(closed, response.onclose || response.onClose);","missing":[{"startCol":20,"endCol":72},{"startCol":35,"endCol":71}]},"61":{"partial":false,"source":"                                _response.write(chunk, response.charset);","missing":[{"startCol":32,"endCol":72}]},"81":{"partial":false,"source":"                        _response.end();","missing":[{"startCol":24,"endCol":39}]},"94":{"partial":false,"source":"            stopped.reject(err);","missing":[{"startCol":12,"endCol":31}]},"114":{"partial":false,"source":"            listening.reject(err);","missing":[{"startCol":12,"endCol":33}]},"129":{"partial":false,"source":"            return Q.reject(new Error(\"A server cannot be restarted or \" +","missing":[{}]},"130":{"partial":false,"source":"            \"started on a new port\"));","missing":[{}]},"147":{"partial":false,"source":"            return this.node.port;","missing":[{"startCol":12,"endCol":34}]},"153":{"partial":false,"source":"            return this.node.host;","missing":[{"startCol":12,"endCol":34}]},"194":{"partial":true,"source":"        port: request.port === (ssl ? 443 : 80) ? null : request.port,","missing":[{"startCol":38,"endCol":41},{"startCol":50,"endCol":54}]},"242":{"partial":false,"source":"        return;","missing":[{"startCol":8,"endCol":15}]},"245":{"partial":false,"source":"        response = [response];","missing":[{"startCol":8,"endCol":30}]},"248":{"partial":false,"source":"        response = {","missing":[{}]},"249":{"partial":false,"source":"            status: 200,","missing":[{}]},"250":{"partial":false,"source":"            headers: {},","missing":[{}]},"251":{"partial":false,"source":"            body: response","missing":[{}]},"252":{"partial":false,"source":"        }","missing":[{}]},"253":{"partial":false,"source":"    }","missing":[{}]},"271":{"partial":true,"source":"        var http = ssl ? HTTPS : HTTP;","missing":[{"startCol":25,"endCol":30}]},"279":{"partial":true,"source":"            \"port\": request.port || (ssl ? 443 : 80),","missing":[{"startCol":43,"endCol":46},{"startCol":49,"endCol":51}]},"288":{"partial":false,"source":"                console.warn(error && error.stack || error);","missing":[{"startCol":16,"endCol":59},{"startCol":29,"endCol":49}]},"289":{"partial":false,"source":"                deferred.reject(error);","missing":[{"startCol":16,"endCol":38}]},"294":{"partial":false,"source":"            deferred.reject(error);","missing":[{"startCol":12,"endCol":34}]},"301":{"partial":false,"source":"                    end = Q.when(end, function () {","missing":[{}]},"302":{"partial":false,"source":"                        return Q.when(chunk, function (chunk) {","missing":[{}]},"303":{"partial":false,"source":"                            _request.write(chunk, request.charset);","missing":[{"startCol":28,"endCol":67},{}]},"304":{"partial":false,"source":"                        });","missing":[{}]},"305":{"partial":false,"source":"                    });","missing":[{}]},"335":{"partial":false,"source":"            var error = new Error(\"HTTP request failed with code \" + response.status);","missing":[{"startCol":12,"endCol":86},{"startCol":34,"endCol":84}]},"336":{"partial":false,"source":"            error.response = response;","missing":[{"startCol":12,"endCol":38}]},"337":{"partial":false,"source":"            throw error;","missing":[{"startCol":12,"endCol":24}]}},"source":"/**\n * A promise-based Q-JSGI server and client API.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar HTTP = require(\"http\"); // node\nvar HTTPS = require(\"https\"); // node\nvar URL = require(\"url2\"); // node\nvar Q = require(\"q\");\nvar Reader = require(\"./reader\");\n\n/**\n * @param {respond(request Request)} respond a JSGI responder function that\n * receives a Request object as its argument.  The JSGI responder promises to\n * return an object of the form `{status, headers, body}`.  The status and\n * headers must be fully resolved, but the body may be a promise for an object\n * with a `forEach(write(chunk String))` method, albeit an array of strings.\n * The `forEach` method may promise to resolve when all chunks have been\n * written.\n * @returns a Node Server object.\n */\nexports.Server = function (respond) {\n    var self = Object.create(exports.Server.prototype);\n\n    var server = HTTP.createServer(function (_request, _response) {\n        var request = exports.ServerRequest(_request);\n        var response = exports.ServerResponse(_response);\n\n        var closed = Q.defer();\n        _request.on(\"end\", function (error, value) {\n            if (error) {\n                closed.reject(error);\n            } else {\n                closed.resolve(value);\n            }\n        });\n\n        Q.when(request, function (request) {\n            return Q.when(respond(request, response), function (response) {\n                if (!response)\n                    return;\n\n                _response.writeHead(response.status, response.headers);\n\n                if (response.onclose || response.onClose)\n                    Q.when(closed, response.onclose || response.onClose);\n\n                return Q.when(response.body, function (body) {\n                    var length;\n                    if (\n                        Array.isArray(body) &&\n                        (length = body.length) &&\n                        body.every(function (chunk) {\n                            return typeof chunk === \"string\"\n                        })\n                    ) {\n                        body.forEach(function (chunk, i) {\n                            if (i < length - 1) {\n                                _response.write(chunk, response.charset);\n                            } else {\n                                _response.end(chunk, response.charset);\n                            }\n                        });\n                    } else if (body) {\n                        var end;\n                        var done = body.forEach(function (chunk) {\n                            end = Q.when(end, function () {\n                                return Q.when(chunk, function (chunk) {\n                                    _response.write(chunk, response.charset);\n                                });\n                            });\n                        });\n                        return Q.when(done, function () {\n                            return Q.when(end, function () {\n                                _response.end();\n                            });\n                        });\n                    } else {\n                        _response.end();\n                    }\n                });\n\n            })\n        })\n        .done(); // should be .fail(self.emitter(\"error\"))\n\n    });\n\n    var stopped = Q.defer();\n    server.on(\"close\", function (err) {\n        if (err) {\n            stopped.reject(err);\n        } else {\n            stopped.resolve();\n        }\n    });\n\n    /***\n     * Stops the server.\n     * @returns {Promise * Undefined} a promise that will\n     * resolve when the server is stopped.\n     */\n    self.stop = function () {\n        server.close();\n        listening = undefined;\n        return stopped.promise;\n    };\n\n    var listening = Q.defer();\n    server.on(\"listening\", function (err) {\n        if (err) {\n            listening.reject(err);\n        } else {\n            listening.resolve(self);\n        }\n    });\n\n    /***\n     * Starts the server, listening on the given port\n     * @param {Number} port\n     * @returns {Promise * Undefined} a promise that will\n     * resolve when the server is ready to receive\n     * connections\n     */\n    self.listen = function (/*...args*/) {\n        if (typeof server.port !== \"undefined\")\n            return Q.reject(new Error(\"A server cannot be restarted or \" +\n            \"started on a new port\"));\n        server.listen.apply(server, arguments);\n        return listening.promise;\n    };\n\n    self.stopped = stopped.promise;\n\n    self.node = server;\n    self.nodeServer = server; // Deprecated\n\n    return self;\n};\n\nObject.defineProperties(exports.Server, {\n\n    port: {\n        get: function () {\n            return this.node.port;\n        }\n    },\n\n    host: {\n        get: function () {\n            return this.node.host;\n        }\n    }\n\n});\n\n/**\n * A wrapper for a Node HTTP Request, as received by\n * the Q HTTP Server, suitable for use by the Q HTTP Client.\n */\nexports.ServerRequest = function (_request, ssl) {\n    var request = Object.create(_request);\n    /*** {Array} HTTP version. (JSGI) */\n    request.version = _request.httpVersion.split(\".\").map(Math.floor);\n    /*** {String} HTTP method, e.g., `\"GET\"` (JSGI) */\n    request.method = _request.method;\n    /*** {String} path, starting with `\"/\"` */\n    request.path = _request.url;\n    /*** {String} pathInfo, starting with `\"/\"`, the\n     * portion of the path that has not yet\n     * been routed (JSGI) */\n    request.pathInfo = URL.parse(_request.url).pathname;\n    /*** {String} scriptName, the portion of the path that\n     * has already been routed (JSGI) */\n    request.scriptName = \"\";\n    /*** {String} (JSGI) */\n    request.scheme = \"http\";\n\n    request.host = _request.headers.host;\n    request.port = _request.connection.address().port;\n\n    var socket = _request.socket;\n    /*** {String} */\n    request.remoteHost = socket.remoteAddress;\n    /*** {Number} */\n    request.remotePort = socket.remotePort;\n\n    /*** {String} url */\n    request.url = URL.format({\n        protocol: request.scheme,\n        hostname: _request.headers.host,\n        port: request.port === (ssl ? 443 : 80) ? null : request.port,\n        path: request.path\n    });\n    /*** A Q IO asynchronous text reader */\n    request.body = Reader(_request);\n    /*** {Object} HTTP headers (JSGI)*/\n    request.headers = _request.headers;\n    /*** The underlying Node request */\n    request.node = _request;\n    request.nodeRequest = _request; // Deprecated\n    /*** The underlying Node TCP connection */\n    request.nodeConnection = _request.connection;\n\n    return Q.when(request.body, function (body) {\n        request.body = body;\n        return request;\n    });\n};\n\nexports.ServerResponse = function (_response, ssl) {\n    var response = Object.create(_response);\n    response.ssl = ssl;\n    response.node = _response;\n    response.nodeResponse = _response; // Deprecated\n    return response;\n};\n\nexports.normalizeRequest = function (request) {\n    if (typeof request === \"string\") {\n        request = {\n            url: request\n        };\n    }\n    if (request.url) {\n        var url = URL.parse(request.url);\n        request.host = url.hostname;\n        request.port = url.port;\n        request.ssl = url.protocol === \"https:\";\n        request.method = request.method || \"GET\";\n        request.path = (url.pathname || \"\") + (url.search || \"\");\n        request.headers = request.headers || {};\n        request.headers.host = url.hostname; // FIXME name consistency\n    }\n    return request;\n};\n\nexports.normalizeResponse = function (response) {\n    if (response === void 0) {\n        return;\n    }\n    if (typeof response == \"string\") {\n        response = [response];\n    }\n    if (response.forEach) {\n        response = {\n            status: 200,\n            headers: {},\n            body: response\n        }\n    }\n    return response;\n};\n\n/**\n * Issues an HTTP request.\n *\n * @param {Request {host, port, method, path, headers,\n * body}} request (may be a promise)\n * @returns {Promise * Response} promise for a response\n */\nexports.request = function (request) {\n    return Q.when(request, function (request) {\n\n        request = exports.normalizeRequest(request);\n\n        var deferred = Q.defer();\n        var ssl = request.ssl;\n        var http = ssl ? HTTPS : HTTP;\n\n        var headers = request.headers || {};\n\n        headers.host = headers.host || request.host;\n\n        var _request = http.request({\n            \"host\": request.host,\n            \"port\": request.port || (ssl ? 443 : 80),\n            \"path\": request.path || \"/\",\n            \"method\": request.method || \"GET\",\n            \"headers\": headers\n        }, function (_response) {\n            deferred.resolve(exports.ClientResponse(_response, request.charset));\n            _response.on(\"error\", function (error) {\n                // TODO find a better way to channel\n                // this into the response\n                console.warn(error && error.stack || error);\n                deferred.reject(error);\n            });\n        });\n\n        _request.on(\"error\", function (error) {\n            deferred.reject(error);\n        });\n\n        Q.when(request.body, function (body) {\n            var end, done;\n            if (body) {\n                done = body.forEach(function (chunk) {\n                    end = Q.when(end, function () {\n                        return Q.when(chunk, function (chunk) {\n                            _request.write(chunk, request.charset);\n                        });\n                    });\n                });\n            }\n            return Q.when(end, function () {\n                return Q.when(done, function () {\n                    _request.end();\n                });\n            });\n        });\n\n        return deferred.promise;\n    });\n};\n\n/**\n * Issues a GET request to the given URL and returns\n * a promise for a `String` containing the entirety\n * of the response.\n *\n * @param {String} url\n * @returns {Promise * String} or a rejection if the\n * status code is not exactly 200.  The reason for the\n * rejection is the full response object.\n */\nexports.read = function (request, qualifier) {\n    qualifier = qualifier || function (response) {\n        return response.status === 200;\n    };\n    return Q.when(exports.request(request), function (response) {\n        if (!qualifier(response)){\n            var error = new Error(\"HTTP request failed with code \" + response.status);\n            error.response = response;\n            throw error;\n        }\n        return Q.post(response.body, 'read', []);\n    });\n};\n\n\n/**\n * A wrapper for the Node HTTP Response as provided\n * by the Q HTTP Client API, suitable for use by the\n * Q HTTP Server API.\n */\nexports.ClientResponse = function (_response, charset) {\n    var response = Object.create(exports.ClientResponse.prototype);\n    /*** {Number} HTTP status code */\n    response.status = _response.statusCode;\n    /*** HTTP version */\n    response.version = _response.httpVersion;\n    /*** {Object} HTTP headers */\n    response.headers = _response.headers;\n    /***\n     * A Q IO asynchronous text reader.\n     */\n    response.node = _response;\n    response.nodeResponse = _response; // Deprecated\n    response.nodeConnection = _response.connection; // Deprecated\n    return Q.when(Reader(_response, charset), function (body) {\n        response.body = body;\n        return response;\n    });\n};","blocks":{"total":61,"seen":42,"missing":19,"percentage":0.6885245901639344}},"hash":"e1f9dae373c3f00825c8f1c551414166"},"/Users/kris/q-io/http-apps.js":{"stats":{"percentage":0.7971631205673759,"lines":[{"lineno":110},{"lineno":133},{"lineno":149},{"lineno":173},{"lineno":174},{"lineno":176},{"lineno":177},{"lineno":189},{"lineno":190},{"lineno":192},{"lineno":193},{"lineno":195},{"lineno":196},{"lineno":198},{"lineno":216},{"lineno":221},{"lineno":231},{"lineno":265},{"lineno":266},{"lineno":267},{"lineno":268},{"lineno":270},{"lineno":271},{"lineno":306},{"lineno":307},{"lineno":308},{"lineno":309},{"lineno":310},{"lineno":311},{"lineno":312},{"lineno":313},{"lineno":314},{"lineno":315},{"lineno":317},{"lineno":318},{"lineno":319},{"lineno":320},{"lineno":321},{"lineno":322},{"lineno":323},{"lineno":325},{"lineno":326},{"lineno":327},{"lineno":328},{"lineno":329},{"lineno":331},{"lineno":335},{"lineno":364},{"lineno":373},{"lineno":388},{"lineno":389},{"lineno":390},{"lineno":408},{"lineno":410},{"lineno":431},{"lineno":465},{"lineno":474},{"lineno":475},{"lineno":485},{"lineno":486},{"lineno":496},{"lineno":497},{"lineno":507},{"lineno":508},{"lineno":518},{"lineno":519},{"lineno":529},{"lineno":530},{"lineno":535},{"lineno":539},{"lineno":543},{"lineno":547},{"lineno":551},{"lineno":562},{"lineno":565},{"lineno":570},{"lineno":572},{"lineno":576},{"lineno":583},{"lineno":592},{"lineno":593},{"lineno":594},{"lineno":595},{"lineno":619},{"lineno":621},{"lineno":622},{"lineno":623},{"lineno":624},{"lineno":625},{"lineno":627},{"lineno":634},{"lineno":636},{"lineno":637},{"lineno":638},{"lineno":639},{"lineno":640},{"lineno":642},{"lineno":643},{"lineno":644},{"lineno":645},{"lineno":646},{"lineno":647},{"lineno":649},{"lineno":651},{"lineno":654},{"lineno":656},{"lineno":659},{"lineno":680},{"lineno":685},{"lineno":686},{"lineno":687},{"lineno":694},{"lineno":695},{"lineno":696},{"lineno":697},{"lineno":698},{"lineno":699},{"lineno":712},{"lineno":713},{"lineno":715},{"lineno":716},{"lineno":729},{"lineno":730},{"lineno":731},{"lineno":733},{"lineno":734},{"lineno":735},{"lineno":737},{"lineno":738},{"lineno":740},{"lineno":741},{"lineno":742},{"lineno":746},{"lineno":748},{"lineno":749},{"lineno":753},{"lineno":756},{"lineno":757},{"lineno":763},{"lineno":765},{"lineno":766},{"lineno":769},{"lineno":771},{"lineno":786},{"lineno":787},{"lineno":788},{"lineno":789},{"lineno":790},{"lineno":791},{"lineno":793},{"lineno":807},{"lineno":808},{"lineno":809},{"lineno":810},{"lineno":811},{"lineno":812},{"lineno":816},{"lineno":828},{"lineno":829},{"lineno":831},{"lineno":844},{"lineno":845},{"lineno":846},{"lineno":859},{"lineno":861},{"lineno":863},{"lineno":869},{"lineno":870},{"lineno":871},{"lineno":884},{"lineno":885},{"lineno":886},{"lineno":898},{"lineno":899},{"lineno":901},{"lineno":903},{"lineno":905},{"lineno":914},{"lineno":915},{"lineno":916},{"lineno":921},{"lineno":937},{"lineno":940},{"lineno":941},{"lineno":942},{"lineno":945},{"lineno":946},{"lineno":947},{"lineno":948},{"lineno":949},{"lineno":950},{"lineno":951},{"lineno":954},{"lineno":956},{"lineno":958},{"lineno":969},{"lineno":972},{"lineno":973},{"lineno":974},{"lineno":975},{"lineno":978},{"lineno":979},{"lineno":982},{"lineno":983},{"lineno":984},{"lineno":985},{"lineno":990},{"lineno":1006},{"lineno":1009},{"lineno":1010},{"lineno":1011},{"lineno":1014},{"lineno":1016},{"lineno":1018},{"lineno":1019},{"lineno":1022},{"lineno":1023},{"lineno":1024},{"lineno":1025},{"lineno":1027},{"lineno":1028},{"lineno":1030},{"lineno":1044},{"lineno":1045},{"lineno":1047},{"lineno":1048},{"lineno":1049},{"lineno":1050},{"lineno":1051},{"lineno":1053},{"lineno":1057},{"lineno":1060},{"lineno":1135},{"lineno":1136},{"lineno":1146},{"lineno":1159},{"lineno":1160},{"lineno":1162},{"lineno":1165},{"lineno":1167},{"lineno":1169},{"lineno":1180},{"lineno":1181},{"lineno":1182},{"lineno":1183},{"lineno":1186},{"lineno":1217},{"lineno":1218},{"lineno":1219},{"lineno":1220},{"lineno":1221},{"lineno":1222},{"lineno":1224},{"lineno":1228},{"lineno":1229},{"lineno":1231},{"lineno":1232},{"lineno":1233},{"lineno":1234},{"lineno":1235},{"lineno":1237},{"lineno":1240},{"lineno":1245},{"lineno":1247},{"lineno":1252},{"lineno":1279},{"lineno":1280},{"lineno":1291},{"lineno":1297},{"lineno":1306},{"lineno":1339},{"lineno":1344},{"lineno":1347},{"lineno":1348},{"lineno":1372},{"lineno":1373},{"lineno":1374},{"lineno":1375},{"lineno":1376},{"lineno":1378},{"lineno":1389},{"lineno":1390},{"lineno":1393},{"lineno":1401},{"lineno":1402},{"lineno":1403}],"missing":286,"seen":1124,"total":1410,"coverage":{"110":{"partial":false,"source":"        return Math.random().toString(36).slice(2) + Math.random().toString(36).slice(2);","missing":[{"startCol":8,"endCol":89},{"startCol":15,"endCol":50},{"startCol":26,"endCol":28},{"startCol":37,"endCol":41},{"startCol":53,"endCol":88},{"startCol":64,"endCol":66},{"startCol":75,"endCol":79}]},"133":{"partial":false,"source":"            return notFound(request, response);","missing":[{"startCol":12,"endCol":47},{"startCol":19,"endCol":46}]},"149":{"partial":false,"source":"                return response;","missing":[{"startCol":16,"endCol":32}]},"173":{"partial":false,"source":"    present = present || function () {","missing":[{}]},"174":{"partial":false,"source":"        return new Date();","missing":[{},{"startCol":8,"endCol":26}]},"175":{"partial":false,"source":"    };","missing":[{}]},"176":{"partial":false,"source":"    return exports.Trap(app, function (response, request) {","missing":[{}]},"177":{"partial":false,"source":"        response.headers[\"date\"] = \"\" + present();","missing":[{},{"startCol":8,"endCol":50},{"startCol":35,"endCol":49},{"startCol":40,"endCol":49}]},"178":{"partial":false,"source":"    });","missing":[{}]},"189":{"partial":false,"source":"    future = future || function () {","missing":[{}]},"190":{"partial":false,"source":"        return new Date(new Date().getTime() + farFuture);","missing":[{},{"startCol":24,"endCol":56},{"startCol":8,"endCol":58}]},"191":{"partial":false,"source":"    };","missing":[{}]},"192":{"partial":false,"source":"    app = exports.Tap(app, function (request, response) {","missing":[{}]},"193":{"partial":false,"source":"        request.permanent = future;","missing":[{},{"startCol":8,"endCol":35}]},"194":{"partial":false,"source":"    });","missing":[{}]},"195":{"partial":false,"source":"    app = exports.Trap(app, function (response, request) {","missing":[{}]},"196":{"partial":false,"source":"        response.headers[\"expires\"] = \"\" + future();","missing":[{"startCol":8,"endCol":52},{},{"startCol":38,"endCol":51},{"startCol":43,"endCol":51}]},"197":{"partial":false,"source":"    });","missing":[{}]},"198":{"partial":false,"source":"    return app;","missing":[{"startCol":4,"endCol":15}]},"216":{"partial":false,"source":"        paths = {};","missing":[{"startCol":8,"endCol":19}]},"221":{"partial":false,"source":"            return notFound(request, response);","missing":[{"startCol":12,"endCol":47},{"startCol":19,"endCol":46}]},"231":{"partial":false,"source":"        return notFound(request, response);","missing":[{"startCol":8,"endCol":43},{"startCol":15,"endCol":42}]},"265":{"partial":false,"source":"    status = status || 200;","missing":[{"startCol":4,"endCol":27},{"startCol":13,"endCol":26}]},"266":{"partial":false,"source":"    content = content || \"\";","missing":[{"startCol":4,"endCol":28},{"startCol":14,"endCol":27}]},"267":{"partial":false,"source":"    if (typeof content === \"string\") {","missing":[{"startCol":8,"endCol":35}]},"268":{"partial":false,"source":"        content = [content];","missing":[{"startCol":8,"endCol":28}]},"270":{"partial":false,"source":"    contentType = contentType || \"text/plain\";","missing":[{"startCol":4,"endCol":46},{"startCol":18,"endCol":45}]},"271":{"partial":false,"source":"    return {","missing":[{}]},"272":{"partial":false,"source":"        \"status\": status,","missing":[{}]},"273":{"partial":false,"source":"        \"headers\": {","missing":[{}]},"274":{"partial":false,"source":"            \"content-type\": contentType","missing":[{}]},"275":{"partial":false,"source":"        },","missing":[{}]},"276":{"partial":false,"source":"        \"body\": content","missing":[{}]},"277":{"partial":false,"source":"    };","missing":[{}]},"306":{"partial":false,"source":"        options = {};","missing":[{"startCol":8,"endCol":21}]},"307":{"partial":false,"source":"    options.notFound = options.notFound || exports.notFound;","missing":[{"startCol":4,"endCol":60},{"startCol":23,"endCol":59}]},"308":{"partial":false,"source":"    options.file = options.file || exports.file;","missing":[{"startCol":4,"endCol":48},{"startCol":19,"endCol":47}]},"309":{"partial":false,"source":"    options.directory = options.directory || exports.directory;","missing":[{"startCol":4,"endCol":63},{"startCol":24,"endCol":62}]},"310":{"partial":false,"source":"    root = FS.canonical(root);","missing":[{"startCol":4,"endCol":30},{"startCol":11,"endCol":29}]},"311":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"312":{"partial":false,"source":"        var redirect = options.redirect || (","missing":[{}]},"313":{"partial":false,"source":"            request.permanent || options.permanent ?","missing":[{},{"startCol":12,"endCol":50}]},"314":{"partial":false,"source":"            exports.permanentRedirect :","missing":[{},{"startCol":12,"endCol":37}]},"315":{"partial":false,"source":"            exports.temporaryRedirect","missing":[{},{"startCol":12,"endCol":37}]},"316":{"partial":false,"source":"        );","missing":[{}]},"317":{"partial":false,"source":"        return Q.when(root, function (root) {","missing":[{}]},"318":{"partial":false,"source":"            var path = FS.join(root, request.pathInfo.slice(1));","missing":[{},{"startCol":12,"endCol":64},{"startCol":23,"endCol":63},{"startCol":37,"endCol":62}]},"319":{"partial":false,"source":"            return Q.when(FS.canonical(path), function (canonical) {","missing":[{},{"startCol":26,"endCol":44}]},"320":{"partial":false,"source":"                if (!FS.contains(root, canonical))","missing":[{},{"startCol":21,"endCol":49}]},"321":{"partial":false,"source":"                    return options.notFound(request, response);","missing":[{},{"startCol":27,"endCol":62},{"startCol":20,"endCol":63}]},"322":{"partial":false,"source":"                if (path !== canonical && options.redirectSymbolicLinks)","missing":[{},{"startCol":20,"endCol":38}]},"323":{"partial":false,"source":"                    return redirect(request, FS.relativeFromFile(path, canonical));","missing":[{},{"startCol":20,"endCol":83},{"startCol":27,"endCol":82},{"startCol":45,"endCol":81}]},"324":{"partial":false,"source":"                // TODO: relativeFromFile should be designed for URL’s, not generalized paths.","missing":[{}]},"325":{"partial":false,"source":"                return Q.when(FS.stat(canonical), function (stat) {","missing":[{},{"startCol":30,"endCol":48}]},"326":{"partial":false,"source":"                    if (stat.isFile()) {","missing":[{},{"startCol":24,"endCol":37}]},"327":{"partial":false,"source":"                        return options.file(request, canonical, options.contentType);","missing":[{},{"startCol":31,"endCol":84},{"startCol":24,"endCol":85}]},"328":{"partial":false,"source":"                    } else if (stat.isDirectory()) {","missing":[{"startCol":31,"endCol":49},{}]},"329":{"partial":false,"source":"                        return options.directory(request, canonical, options.contentType);","missing":[{},{"startCol":31,"endCol":89},{"startCol":24,"endCol":90}]},"330":{"partial":false,"source":"                    } else {","missing":[{}]},"331":{"partial":false,"source":"                        return options.notFound(request, response);","missing":[{},{"startCol":24,"endCol":67},{"startCol":31,"endCol":66}]},"332":{"partial":false,"source":"                    }","missing":[{}]},"333":{"partial":false,"source":"                });","missing":[{}]},"334":{"partial":false,"source":"            }, function (reason) {","missing":[{}]},"335":{"partial":false,"source":"                return options.notFound(request, response);","missing":[{},{"startCol":23,"endCol":58},{"startCol":16,"endCol":59}]},"336":{"partial":false,"source":"            });","missing":[{}]},"337":{"partial":false,"source":"        });","missing":[{}]},"338":{"partial":false,"source":"    };","missing":[{}]},"364":{"partial":false,"source":"                etag != request.headers[\"if-range\"]","missing":[{"startCol":16,"endCol":51}]},"373":{"partial":false,"source":"                        return exports.responseForStatus(416); // not satisfiable","missing":[{"startCol":24,"endCol":62},{"startCol":31,"endCol":61}]},"388":{"partial":false,"source":"            if (etag == request.headers[\"if-none-match\"])","missing":[{"startCol":16,"endCol":56}]},"389":{"partial":false,"source":"                return exports.responseForStatus(304);","missing":[{"startCol":16,"endCol":54},{"startCol":23,"endCol":53}]},"390":{"partial":false,"source":"            headers[\"content-length\"] = \"\" + stat.size;","missing":[{"startCol":12,"endCol":55},{"startCol":40,"endCol":54}]},"408":{"partial":false,"source":"        return;","missing":[{"startCol":8,"endCol":15}]},"410":{"partial":false,"source":"        return;","missing":[{"startCol":8,"endCol":15}]},"431":{"partial":false,"source":"        return;","missing":[{"startCol":8,"endCol":15}]},"465":{"partial":false,"source":"    return Q.reject(\"directory listing not yet implemented\");","missing":[{"startCol":4,"endCol":61},{"startCol":11,"endCol":60}]},"474":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"475":{"partial":false,"source":"        return exports.permanentRedirect(request, location, status, tree);","missing":[{"startCol":8,"endCol":74},{"startCol":15,"endCol":73},{}]},"476":{"partial":false,"source":"    };","missing":[{}]},"485":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"486":{"partial":false,"source":"        return exports.permanentRedirect(request, location, status, true);","missing":[{},{"startCol":8,"endCol":74},{"startCol":15,"endCol":73}]},"487":{"partial":false,"source":"    };","missing":[{}]},"496":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"497":{"partial":false,"source":"        return exports.temporaryRedirect(request, location, status, tree);","missing":[{"startCol":8,"endCol":74},{"startCol":15,"endCol":73},{}]},"498":{"partial":false,"source":"    };","missing":[{}]},"507":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"508":{"partial":false,"source":"        return exports.temporaryRedirect(request, location, status, true);","missing":[{"startCol":8,"endCol":74},{"startCol":15,"endCol":73},{}]},"509":{"partial":false,"source":"    };","missing":[{}]},"518":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"519":{"partial":false,"source":"        return exports.redirect(request, location, status, tree);","missing":[{},{"startCol":15,"endCol":64},{"startCol":8,"endCol":65}]},"520":{"partial":false,"source":"    };","missing":[{}]},"529":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"530":{"partial":false,"source":"        return exports.redirect(request, location, status, true);","missing":[{"startCol":8,"endCol":65},{"startCol":15,"endCol":64},{}]},"531":{"partial":false,"source":"    };","missing":[{}]},"535":{"partial":false,"source":"    return exports.redirect(request, location, status || 301);","missing":[{"startCol":4,"endCol":62},{"startCol":11,"endCol":61},{"startCol":47,"endCol":60}]},"539":{"partial":false,"source":"    return exports.redirect(request, location, status || 301, true);","missing":[{"startCol":4,"endCol":68},{"startCol":11,"endCol":67},{"startCol":47,"endCol":60}]},"543":{"partial":false,"source":"    return exports.redirect(request, location, status || 307);","missing":[{"startCol":4,"endCol":62},{"startCol":11,"endCol":61},{"startCol":47,"endCol":60}]},"547":{"partial":false,"source":"    return exports.redirect(request, location, status || 307, true);","missing":[{"startCol":4,"endCol":68},{"startCol":11,"endCol":67},{"startCol":47,"endCol":60}]},"551":{"partial":false,"source":"    return exports.redirect(request, location, status, true);","missing":[{"startCol":4,"endCol":61},{"startCol":11,"endCol":60}]},"562":{"partial":false,"source":"    status = status || (request.permanent ? 301 : 307);","missing":[{"startCol":4,"endCol":55},{"startCol":13,"endCol":54},{"startCol":44,"endCol":47},{"startCol":50,"endCol":53}]},"565":{"partial":false,"source":"    location = URL.resolve(request.url, location);","missing":[{"startCol":4,"endCol":50},{"startCol":15,"endCol":49}]},"570":{"partial":false,"source":"        location = URL.resolve(","missing":[{}]},"571":{"partial":false,"source":"            location,","missing":[{}]},"572":{"partial":false,"source":"            request.pathInfo.replace(/^\\//, \"\")","missing":[{},{"startCol":12,"endCol":47}]},"573":{"partial":false,"source":"        );","missing":[{}]},"576":{"partial":false,"source":"    return {","missing":[{}]},"577":{"partial":false,"source":"        \"status\": status,","missing":[{}]},"578":{"partial":false,"source":"        \"headers\": {","missing":[{}]},"579":{"partial":false,"source":"            \"location\": location,","missing":[{}]},"580":{"partial":false,"source":"            \"content-type\": \"text/html\"","missing":[{}]},"581":{"partial":false,"source":"        },","missing":[{}]},"582":{"partial":false,"source":"        \"body\": [","missing":[{}]},"583":{"partial":false,"source":"            'Go to <a href=\"' + location + '\">' + // TODO escape","missing":[{},{"startCol":12,"endCol":40}]},"584":{"partial":false,"source":"            location +","missing":[{}]},"585":{"partial":false,"source":"            \"</a>\"","missing":[{}]},"586":{"partial":false,"source":"        ]","missing":[{}]},"587":{"partial":false,"source":"    };","missing":[{}]},"592":{"partial":false,"source":"        var location = app;","missing":[{"startCol":8,"endCol":27}]},"593":{"partial":false,"source":"        app = function (request) {","missing":[{}]},"594":{"partial":false,"source":"            request.url = location;","missing":[{},{"startCol":12,"endCol":35}]},"595":{"partial":false,"source":"            return request;","missing":[{"startCol":12,"endCol":27},{}]},"596":{"partial":false,"source":"        };","missing":[{}]},"619":{"partial":false,"source":"    var keys = Object.keys(methods);","missing":[{"startCol":4,"endCol":36},{"startCol":15,"endCol":35}]},"621":{"partial":false,"source":"        methodNotAllowed = exports.methodNotAllowed;","missing":[{"startCol":8,"endCol":52}]},"622":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"623":{"partial":false,"source":"        var method = request.method;","missing":[{"startCol":8,"endCol":36},{}]},"624":{"partial":false,"source":"        if (Object.has(keys, method)) {","missing":[{},{"startCol":12,"endCol":36}]},"625":{"partial":false,"source":"            return Object.get(methods, method)(request, response);","missing":[{"startCol":12,"endCol":66},{"startCol":19,"endCol":65},{"startCol":29,"endCol":46},{}]},"626":{"partial":false,"source":"        } else {","missing":[{}]},"627":{"partial":false,"source":"            return methodNotAllowed(request, response);","missing":[{"startCol":12,"endCol":55},{},{"startCol":19,"endCol":54}]},"628":{"partial":false,"source":"        }","missing":[{}]},"629":{"partial":false,"source":"    };","missing":[{}]},"634":{"partial":false,"source":"        var keys = Object.keys(types);","missing":[{"startCol":8,"endCol":38},{"startCol":19,"endCol":37}]},"636":{"partial":false,"source":"            notAcceptable = exports.notAcceptable;","missing":[{"startCol":12,"endCol":50}]},"637":{"partial":false,"source":"        return function (request, response) {","missing":[{}]},"638":{"partial":false,"source":"            var header = requestHeader;","missing":[{"startCol":12,"endCol":39},{}]},"639":{"partial":false,"source":"            if (typeof header === \"function\") {","missing":[{},{"startCol":16,"endCol":44}]},"640":{"partial":false,"source":"                header = requestHeader(request);","missing":[{"startCol":25,"endCol":47},{},{"startCol":16,"endCol":48}]},"641":{"partial":false,"source":"            }","missing":[{}]},"642":{"partial":false,"source":"            var accept = request.headers[requestHeader] || \"*\";","missing":[{},{"startCol":12,"endCol":63},{"startCol":25,"endCol":62}]},"643":{"partial":false,"source":"            var type = MIME_PARSE.bestMatch(keys, accept);","missing":[{"startCol":23,"endCol":57},{},{"startCol":12,"endCol":58}]},"644":{"partial":false,"source":"            request.terms = request.terms || {};","missing":[{"startCol":12,"endCol":48},{},{"startCol":28,"endCol":47}]},"645":{"partial":false,"source":"            request.terms[responseHeader] = type;","missing":[{"startCol":12,"endCol":49},{}]},"646":{"partial":false,"source":"            if (Object.has(keys, type)) {","missing":[{},{"startCol":16,"endCol":38}]},"647":{"partial":false,"source":"                return Q.when(types[type](request, response), function (response) {","missing":[{"startCol":30,"endCol":60},{}]},"648":{"partial":false,"source":"                    if (","missing":[{}]},"649":{"partial":false,"source":"                        respond !== null &&","missing":[{},{"startCol":24,"endCol":40}]},"650":{"partial":false,"source":"                        response &&","missing":[{}]},"651":{"partial":false,"source":"                        response.status === 200 &&","missing":[{},{"startCol":24,"endCol":47}]},"652":{"partial":false,"source":"                        response.headers","missing":[{}]},"653":{"partial":false,"source":"                    ) {","missing":[{}]},"654":{"partial":false,"source":"                        response.headers[responseHeader] = type;","missing":[{},{"startCol":24,"endCol":64}]},"655":{"partial":false,"source":"                    }","missing":[{}]},"656":{"partial":false,"source":"                    return response;","missing":[{},{"startCol":20,"endCol":36}]},"657":{"partial":false,"source":"                });","missing":[{}]},"658":{"partial":false,"source":"            } else {","missing":[{}]},"659":{"partial":false,"source":"                return notAcceptable(request, response);","missing":[{},{"startCol":16,"endCol":56},{"startCol":23,"endCol":55}]},"660":{"partial":false,"source":"            }","missing":[{}]},"661":{"partial":false,"source":"        };","missing":[{}]},"680":{"partial":false,"source":"    return (request.headers.host || \"*\") + \":\" + request.port;","missing":[{"startCol":4,"endCol":62},{"startCol":11,"endCol":40}]},"685":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"686":{"partial":false,"source":"        return Q.when(select(request, response), function (app) {","missing":[{},{"startCol":22,"endCol":47}]},"687":{"partial":false,"source":"            return app(request, response);","missing":[{},{"startCol":12,"endCol":42},{"startCol":19,"endCol":41}]},"688":{"partial":false,"source":"        });","missing":[{}]},"689":{"partial":false,"source":"    };","missing":[{}]},"694":{"partial":false,"source":"    _require = _require || require;","missing":[{"startCol":4,"endCol":35},{"startCol":15,"endCol":34}]},"695":{"partial":false,"source":"    var async = _require.async || _require;","missing":[{"startCol":4,"endCol":43},{"startCol":16,"endCol":42}]},"696":{"partial":false,"source":"    var exports = async(id);","missing":[{"startCol":4,"endCol":28},{"startCol":18,"endCol":27}]},"697":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"698":{"partial":false,"source":"        return Q.when(exports, function (exports) {","missing":[{}]},"699":{"partial":false,"source":"            return exports.app(request, response);","missing":[{"startCol":12,"endCol":50},{},{"startCol":19,"endCol":49}]},"700":{"partial":false,"source":"        });","missing":[{}]},"701":{"partial":false,"source":"    }","missing":[{}]},"702":{"partial":false,"source":"};","missing":[{}]},"712":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"713":{"partial":false,"source":"        return Q.when(app(request, response), null, function (error) {","missing":[{},{"startCol":22,"endCol":44}]},"714":{"partial":false,"source":"            if (!debug)","missing":[{}]},"715":{"partial":false,"source":"                error = undefined;","missing":[{"startCol":16,"endCol":34},{}]},"716":{"partial":false,"source":"            return exports.responseForStatus(500, error && error.stack || error);","missing":[{"startCol":50,"endCol":70},{},{"startCol":12,"endCol":81},{"startCol":19,"endCol":80}]},"717":{"partial":false,"source":"        });","missing":[{}]},"718":{"partial":false,"source":"    };","missing":[{}]},"729":{"partial":false,"source":"    log = log || console.log;","missing":[{"startCol":4,"endCol":29},{"startCol":10,"endCol":28}]},"730":{"partial":false,"source":"    stamp = stamp || function (message) {","missing":[{}]},"731":{"partial":false,"source":"        return new Date().toISOString() + \" \" + message;","missing":[{"startCol":8,"endCol":56},{"startCol":15,"endCol":39},{}]},"732":{"partial":false,"source":"    };","missing":[{}]},"733":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"734":{"partial":false,"source":"        var remoteHost =","missing":[{}]},"735":{"partial":false,"source":"            request.remoteHost + \":\" +","missing":[{},{"startCol":12,"endCol":36}]},"736":{"partial":false,"source":"            request.remotePort;","missing":[{}]},"737":{"partial":false,"source":"        var requestLine =","missing":[{}]},"738":{"partial":false,"source":"            request.method + \" \" +","missing":[{},{"startCol":12,"endCol":32}]},"739":{"partial":false,"source":"            request.path + \" \" +","missing":[{}]},"740":{"partial":false,"source":"            \"HTTP/\" + request.version.join(\".\");","missing":[{},{"startCol":22,"endCol":47}]},"741":{"partial":false,"source":"        log(stamp(","missing":[{}]},"742":{"partial":false,"source":"            remoteHost + \" \" +","missing":[{"startCol":12,"endCol":28},{}]},"743":{"partial":false,"source":"            \"-->     \" +","missing":[{}]},"744":{"partial":false,"source":"            requestLine","missing":[{}]},"745":{"partial":false,"source":"        ));","missing":[{}]},"746":{"partial":false,"source":"        return Q.when(app(request, response), function (response) {","missing":[{},{"startCol":22,"endCol":44}]},"747":{"partial":false,"source":"            if (response) {","missing":[{}]},"748":{"partial":false,"source":"                log(stamp(","missing":[{}]},"749":{"partial":false,"source":"                    remoteHost + \" \" +","missing":[{},{"startCol":20,"endCol":36}]},"750":{"partial":false,"source":"                    \"<== \" +","missing":[{}]},"751":{"partial":false,"source":"                    response.status + \" \" +","missing":[{}]},"752":{"partial":false,"source":"                    requestLine + \" \" +","missing":[{}]},"753":{"partial":false,"source":"                    (response.headers[\"content-length\"] || \"-\")","missing":[{},{"startCol":20,"endCol":63}]},"754":{"partial":false,"source":"                ));","missing":[{}]},"755":{"partial":false,"source":"            } else {","missing":[{}]},"756":{"partial":false,"source":"                log(stamp(","missing":[{}]},"757":{"partial":false,"source":"                    remoteHost + \" \" +","missing":[{},{"startCol":20,"endCol":36}]},"758":{"partial":false,"source":"                    \"... \" +","missing":[{}]},"759":{"partial":false,"source":"                    \"... \" +","missing":[{}]},"760":{"partial":false,"source":"                    requestLine + \" (response undefined / presumed streaming)\"","missing":[{}]},"761":{"partial":false,"source":"                ));","missing":[{}]},"762":{"partial":false,"source":"            }","missing":[{}]},"763":{"partial":false,"source":"            return response;","missing":[{"startCol":12,"endCol":28},{}]},"764":{"partial":false,"source":"        }, function (reason) {","missing":[{}]},"765":{"partial":false,"source":"            log(stamp(","missing":[{}]},"766":{"partial":false,"source":"                remoteHost + \" \" +","missing":[{"startCol":16,"endCol":32},{}]},"767":{"partial":false,"source":"                \"!!!     \" +","missing":[{}]},"768":{"partial":false,"source":"                requestLine + \" \" +","missing":[{}]},"769":{"partial":false,"source":"                (reason && reason.message || reason)","missing":[{},{"startCol":16,"endCol":52},{"startCol":17,"endCol":41}]},"770":{"partial":false,"source":"            ));","missing":[{}]},"771":{"partial":false,"source":"            return Q.reject(reason);","missing":[{"startCol":19,"endCol":35},{},{"startCol":12,"endCol":36}]},"772":{"partial":false,"source":"        });","missing":[{}]},"773":{"partial":false,"source":"    };","missing":[{}]},"786":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"787":{"partial":false,"source":"        var start = new Date();","missing":[{},{"startCol":8,"endCol":31}]},"788":{"partial":false,"source":"        return Q.when(app(request, response), function (response) {","missing":[{},{"startCol":22,"endCol":44}]},"789":{"partial":false,"source":"            var stop = new Date();","missing":[{"startCol":12,"endCol":34},{}]},"790":{"partial":false,"source":"            if (response && response.headers) {","missing":[{"startCol":16,"endCol":44},{}]},"791":{"partial":false,"source":"                response.headers[\"x-response-time\"] = \"\" + (stop - start);","missing":[{"startCol":54,"endCol":73},{"startCol":59,"endCol":73},{},{"startCol":16,"endCol":74}]},"792":{"partial":false,"source":"            }","missing":[{}]},"793":{"partial":false,"source":"            return response;","missing":[{},{"startCol":12,"endCol":28}]},"794":{"partial":false,"source":"        });","missing":[{}]},"795":{"partial":false,"source":"    };","missing":[{}]},"807":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"808":{"partial":false,"source":"        return Q.when(app(request, response), function (response) {","missing":[{},{"startCol":22,"endCol":44}]},"809":{"partial":false,"source":"            if (response && response.headers) {","missing":[{"startCol":16,"endCol":44},{}]},"810":{"partial":false,"source":"                Object.keys(headers).forEach(function (key) {","missing":[{},{"startCol":27,"endCol":36}]},"811":{"partial":false,"source":"                    if (!(key in response.headers)) {","missing":[{},{"startCol":25,"endCol":50}]},"812":{"partial":false,"source":"                        response.headers[key] = headers[key];","missing":[{},{"startCol":24,"endCol":61}]},"813":{"partial":false,"source":"                    }","missing":[{}]},"814":{"partial":false,"source":"                });","missing":[{}]},"815":{"partial":false,"source":"            }","missing":[{}]},"816":{"partial":false,"source":"            return response;","missing":[{},{"startCol":12,"endCol":28}]},"817":{"partial":false,"source":"        });","missing":[{}]},"818":{"partial":false,"source":"    };","missing":[{}]},"828":{"partial":false,"source":"    decorators.reversed().forEach(function (Middleware) {","missing":[{},{"startCol":23,"endCol":25}]},"829":{"partial":false,"source":"        app = Middleware(app);","missing":[{},{"startCol":8,"endCol":30},{"startCol":14,"endCol":29}]},"830":{"partial":false,"source":"    });","missing":[{}]},"831":{"partial":false,"source":"    return app;","missing":[{"startCol":4,"endCol":15}]},"844":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"845":{"partial":false,"source":"        return Q.when(app(request, response), function (object) {","missing":[{},{"startCol":22,"endCol":44}]},"846":{"partial":false,"source":"            return exports.json(object, visitor, tabs);","missing":[{},{"startCol":12,"endCol":55},{"startCol":19,"endCol":54}]},"847":{"partial":false,"source":"        });","missing":[{}]},"848":{"partial":false,"source":"    };","missing":[{}]},"859":{"partial":false,"source":"        var json = JSON.stringify(content, visitor, tabs);","missing":[{"startCol":8,"endCol":58},{"startCol":19,"endCol":57}]},"861":{"partial":false,"source":"        return Q.reject(exception);","missing":[{"startCol":8,"endCol":35},{"startCol":15,"endCol":34}]},"863":{"partial":false,"source":"    return exports.ok([json]);","missing":[{"startCol":4,"endCol":30},{"startCol":11,"endCol":29}]},"869":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"870":{"partial":false,"source":"        request.query = QS.parse(URL.parse(request.url).query || \"\");","missing":[{"startCol":8,"endCol":69},{"startCol":24,"endCol":68},{"startCol":33,"endCol":67},{"startCol":42,"endCol":55},{}]},"871":{"partial":false,"source":"        return app(request, response);","missing":[{"startCol":8,"endCol":38},{},{"startCol":15,"endCol":37}]},"872":{"partial":false,"source":"    };","missing":[{}]},"884":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"885":{"partial":false,"source":"        return Q.when(request.body.read(), function (body) {","missing":[{"startCol":22,"endCol":41},{}]},"886":{"partial":false,"source":"            return app(body, request, response);","missing":[{},{"startCol":12,"endCol":48},{"startCol":19,"endCol":47}]},"887":{"partial":false,"source":"        });","missing":[{}]},"888":{"partial":false,"source":"    };","missing":[{}]},"898":{"partial":false,"source":"        badRequest = exports.badRequest;","missing":[{"startCol":8,"endCol":40}]},"899":{"partial":false,"source":"    return exports.ContentRequest(function (content, request, response) {","missing":[{}]},"900":{"partial":false,"source":"        try {","missing":[{}]},"901":{"partial":false,"source":"            var object = JSON.parse(content);","missing":[{"startCol":12,"endCol":45},{"startCol":25,"endCol":44},{}]},"902":{"partial":false,"source":"        } catch (error) {","missing":[{}]},"903":{"partial":false,"source":"            return badRequest(request, error);","missing":[{"startCol":12,"endCol":46},{},{"startCol":19,"endCol":45}]},"904":{"partial":false,"source":"        }","missing":[{}]},"905":{"partial":false,"source":"        return app(object, request, response);","missing":[{"startCol":8,"endCol":46},{"startCol":15,"endCol":45},{}]},"906":{"partial":false,"source":"    });","missing":[{}]},"914":{"partial":false,"source":"    return exports.Method({\"GET\": function (request, response) {","missing":[{}]},"915":{"partial":false,"source":"        return Q.when(app(request, response), function (object) {","missing":[{},{"startCol":22,"endCol":44}]},"916":{"partial":false,"source":"            return {","missing":[{}]},"917":{"partial":false,"source":"                \"status\": 200,","missing":[{}]},"918":{"partial":false,"source":"                \"headers\": {","missing":[{}]},"919":{"partial":false,"source":"                    \"content-type\": \"text/plain\"","missing":[{}]},"920":{"partial":false,"source":"                },","missing":[{}]},"921":{"partial":false,"source":"                \"body\": [inspect(object)]","missing":[{},{"startCol":25,"endCol":40}]},"922":{"partial":false,"source":"            }","missing":[{}]},"923":{"partial":false,"source":"        });","missing":[{}]},"924":{"partial":false,"source":"    }});","missing":[{}]},"937":{"partial":false,"source":"    var sessions = {};","missing":[{"startCol":4,"endCol":22}]},"940":{"partial":false,"source":"            var uuid = UUID.generate();","missing":[{"startCol":12,"endCol":39},{"startCol":23,"endCol":38}]},"941":{"partial":false,"source":"            if (!Object.has(sessions, uuid))","missing":[{"startCol":17,"endCol":43}]},"942":{"partial":false,"source":"                return uuid;","missing":[{"startCol":16,"endCol":28}]},"945":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"946":{"partial":false,"source":"        var cookie = QS.parse(request.headers[\"cookie\"], /[;,]/g);","missing":[{"startCol":8,"endCol":66},{},{"startCol":21,"endCol":65}]},"947":{"partial":false,"source":"        var sessionIds = cookie[\"session.id\"];","missing":[{"startCol":8,"endCol":46},{}]},"948":{"partial":false,"source":"        if (!Array.isArray(sessionIds))","missing":[{"startCol":13,"endCol":38},{}]},"949":{"partial":false,"source":"            sessionIds = [sessionIds];","missing":[{"startCol":12,"endCol":38},{}]},"950":{"partial":false,"source":"        sessionIds = sessionIds.filter(function (sessionId) {","missing":[{}]},"951":{"partial":false,"source":"            return Object.has(sessions, sessionId);","missing":[{},{"startCol":12,"endCol":51},{"startCol":19,"endCol":50}]},"952":{"partial":false,"source":"        });","missing":[{}]},"953":{"partial":false,"source":"        // verifying cookie","missing":[{}]},"954":{"partial":false,"source":"        if (/^\\/~session\\//.test(request.pathInfo)) {","missing":[{"startCol":12,"endCol":50},{}]},"955":{"partial":false,"source":"            if (cookie[\"session.id\"])","missing":[{}]},"956":{"partial":false,"source":"                return exports.TemporaryRedirect(\"../\")(request, response);","missing":[{"startCol":16,"endCol":75},{"startCol":48,"endCol":55},{},{"startCol":23,"endCol":74}]},"957":{"partial":false,"source":"            // TODO more flexible session error page","missing":[{}]},"958":{"partial":false,"source":"            return {","missing":[{}]},"959":{"partial":false,"source":"                \"status\": 404,","missing":[{}]},"960":{"partial":false,"source":"                \"headers\": {","missing":[{}]},"961":{"partial":false,"source":"                    \"content-type\": \"text/plain\"","missing":[{}]},"962":{"partial":false,"source":"                },","missing":[{}]},"963":{"partial":false,"source":"                \"body\": [","missing":[{}]},"964":{"partial":false,"source":"                    \"Access requires cookies\"","missing":[{}]},"965":{"partial":false,"source":"                ]","missing":[{}]},"966":{"partial":false,"source":"            }","missing":[{}]},"967":{"partial":false,"source":"        // session exists","missing":[{}]},"968":{"partial":false,"source":"        } else if (","missing":[{}]},"969":{"partial":false,"source":"            Object.has(cookie, \"session.id\") &&","missing":[{},{"startCol":12,"endCol":44}]},"970":{"partial":false,"source":"            sessionIds.length","missing":[{}]},"971":{"partial":false,"source":"        ) {","missing":[{}]},"972":{"partial":false,"source":"            var session = sessions[sessionIds[0]];","missing":[{"startCol":12,"endCol":50},{}]},"973":{"partial":false,"source":"            session.lastAccess = new Date();","missing":[{"startCol":12,"endCol":44},{}]},"974":{"partial":false,"source":"            request.session = session;","missing":[{"startCol":12,"endCol":38},{}]},"975":{"partial":false,"source":"            return session.route(request, response);","missing":[{"startCol":19,"endCol":51},{},{"startCol":12,"endCol":52}]},"976":{"partial":false,"source":"        // new session","missing":[{}]},"977":{"partial":false,"source":"        } else {","missing":[{}]},"978":{"partial":false,"source":"            var session = {","missing":[{}]},"979":{"partial":false,"source":"                \"id\": nextUuid(),","missing":[{},{"startCol":22,"endCol":32}]},"980":{"partial":false,"source":"                \"lastAccess\": new Date()","missing":[{}]},"981":{"partial":false,"source":"            };","missing":[{}]},"982":{"partial":false,"source":"            sessions[session.id] = session;","missing":[{"startCol":12,"endCol":43},{}]},"983":{"partial":false,"source":"            session.route = Session(session);","missing":[{"startCol":12,"endCol":45},{"startCol":28,"endCol":44},{}]},"984":{"partial":false,"source":"            var response = exports.TemporaryRedirect(request.scriptInfo + \"~session/\")(request, response);","missing":[{"startCol":12,"endCol":106},{},{"startCol":27,"endCol":105},{"startCol":52,"endCol":86},{"startCol":53,"endCol":85}]},"985":{"partial":false,"source":"            response.headers[\"set-cookie\"] = Cookie.stringify(","missing":[{}]},"986":{"partial":false,"source":"                \"session.id\", session.id, {","missing":[{}]},"987":{"partial":false,"source":"                    \"path\": request.scriptInfo","missing":[{}]},"988":{"partial":false,"source":"                }","missing":[{}]},"989":{"partial":false,"source":"            );","missing":[{}]},"990":{"partial":false,"source":"            return response;","missing":[{},{"startCol":12,"endCol":28}]},"991":{"partial":false,"source":"        }","missing":[{}]},"992":{"partial":false,"source":"    };","missing":[{}]},"1006":{"partial":false,"source":"    var sessions = {};","missing":[{"startCol":4,"endCol":22}]},"1009":{"partial":false,"source":"            var uuid = UUID.generate();","missing":[{"startCol":12,"endCol":39},{"startCol":23,"endCol":38}]},"1010":{"partial":false,"source":"            if (!Object.has(sessions, uuid))","missing":[{"startCol":17,"endCol":43}]},"1011":{"partial":false,"source":"                return uuid;","missing":[{"startCol":16,"endCol":28}]},"1014":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"1015":{"partial":false,"source":"        // TODO request.pathInfo and request.scriptInfo","missing":[{}]},"1016":{"partial":false,"source":"        if (request.pathInfo == \"/\") {","missing":[{"startCol":12,"endCol":35},{}]},"1017":{"partial":false,"source":"            // new session","missing":[{}]},"1018":{"partial":false,"source":"            var session = {","missing":[{}]},"1019":{"partial":false,"source":"                \"id\": nextUuid(),","missing":[{"startCol":22,"endCol":32},{}]},"1020":{"partial":false,"source":"                \"lastAccess\": new Date()","missing":[{}]},"1021":{"partial":false,"source":"            };","missing":[{}]},"1022":{"partial":false,"source":"            sessions[session.id] = session;","missing":[{"startCol":12,"endCol":43},{}]},"1023":{"partial":false,"source":"            session.route = Session(session);","missing":[{"startCol":12,"endCol":45},{"startCol":28,"endCol":44},{}]},"1024":{"partial":false,"source":"            return exports.Json(function (request, response) {","missing":[{}]},"1025":{"partial":false,"source":"                return session;","missing":[{},{"startCol":16,"endCol":31}]},"1026":{"partial":false,"source":"            })(request, response);","missing":[{}]},"1027":{"partial":false,"source":"        } else if (Object.has(sessions, request.pathInfo.slice(1))) {","missing":[{},{"startCol":19,"endCol":66},{"startCol":40,"endCol":65}]},"1028":{"partial":false,"source":"            return Object.get(sessions, request.pathInfo.slice(1)).route(request, response);","missing":[{"startCol":12,"endCol":92},{"startCol":19,"endCol":91},{"startCol":29,"endCol":66},{},{"startCol":40,"endCol":65}]},"1029":{"partial":false,"source":"        } else {","missing":[{}]},"1030":{"partial":false,"source":"            return exports.responseForStatus(404, \"Session does not exist\");","missing":[{},{"startCol":12,"endCol":76},{"startCol":19,"endCol":75}]},"1031":{"partial":false,"source":"        }","missing":[{}]},"1032":{"partial":false,"source":"    };","missing":[{}]},"1044":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"1045":{"partial":false,"source":"        var i = 0, ii = cascade.length;","missing":[{},{"startCol":8,"endCol":39}]},"1046":{"partial":false,"source":"        function next() {","missing":[{}]},"1047":{"partial":false,"source":"            var response = cascade[i++](request, response);","missing":[{},{"startCol":12,"endCol":59},{"startCol":27,"endCol":58},{"startCol":35,"endCol":38}]},"1048":{"partial":false,"source":"            if (i < ii) {","missing":[{},{"startCol":16,"endCol":22}]},"1049":{"partial":false,"source":"                return Q.when(response, function (response) {","missing":[{}]},"1050":{"partial":false,"source":"                    if (response.status === 404) {","missing":[{},{"startCol":24,"endCol":47}]},"1051":{"partial":false,"source":"                        return next();","missing":[{"startCol":31,"endCol":37},{},{"startCol":24,"endCol":38}]},"1052":{"partial":false,"source":"                    } else {","missing":[{}]},"1053":{"partial":false,"source":"                        return response;","missing":[{},{"startCol":24,"endCol":40}]},"1054":{"partial":false,"source":"                    }","missing":[{}]},"1055":{"partial":false,"source":"                });","missing":[{}]},"1056":{"partial":false,"source":"            } else {","missing":[{}]},"1057":{"partial":false,"source":"                return response;","missing":[{},{"startCol":16,"endCol":32}]},"1058":{"partial":false,"source":"            }","missing":[{}]},"1059":{"partial":false,"source":"        }","missing":[{}]},"1060":{"partial":false,"source":"        return next();","missing":[{},{"startCol":8,"endCol":22},{"startCol":15,"endCol":21}]},"1061":{"partial":false,"source":"    };","missing":[{}]},"1135":{"partial":false,"source":"    return (status >= 100 && status <= 199) ||","missing":[{},{"startCol":29,"endCol":42},{"startCol":12,"endCol":25},{"startCol":11,"endCol":43}]},"1136":{"partial":false,"source":"        status == 204 || status == 304;","missing":[{"startCol":25,"endCol":38},{},{"startCol":8,"endCol":21}]},"1146":{"partial":false,"source":"        return exports.responseForStatus(status, request.method + \" \" + request.path);","missing":[{"startCol":8,"endCol":86},{"startCol":15,"endCol":85},{"startCol":49,"endCol":69}]},"1159":{"partial":false,"source":"    if (exports.HTTP_STATUS_CODES[status] === undefined)","missing":[{"startCol":8,"endCol":55}]},"1160":{"partial":false,"source":"        throw \"Unknown status code\";","missing":[{"startCol":8,"endCol":36}]},"1162":{"partial":false,"source":"    var message = exports.HTTP_STATUS_CODES[status];","missing":[{"startCol":4,"endCol":52}]},"1165":{"partial":false,"source":"        message += \": \" + optMessage;","missing":[{"startCol":8,"endCol":37},{"startCol":19,"endCol":36}]},"1167":{"partial":false,"source":"    var content = message + \"\\r\\n\";","missing":[{"startCol":4,"endCol":35},{"startCol":18,"endCol":34}]},"1169":{"partial":false,"source":"    var response = {","missing":[{}]},"1170":{"partial":false,"source":"        \"status\": status,","missing":[{}]},"1171":{"partial":false,"source":"        \"headers\": {}","missing":[{}]},"1172":{"partial":false,"source":"    };","missing":[{}]},"1180":{"partial":false,"source":"    if (!exports.STATUS_WITH_NO_ENTITY_BODY(status)) {","missing":[{"startCol":9,"endCol":51}]},"1181":{"partial":false,"source":"        response.headers['content-length'] = content.length;","missing":[{"startCol":8,"endCol":60}]},"1182":{"partial":false,"source":"        response.headers['content-type'] = 'text/plain';","missing":[{"startCol":8,"endCol":56}]},"1183":{"partial":false,"source":"        response.body = [content];","missing":[{"startCol":8,"endCol":34}]},"1186":{"partial":false,"source":"    return response;","missing":[{"startCol":4,"endCol":20}]},"1217":{"partial":false,"source":"    maxRedirects = maxRedirects || 20;","missing":[{"startCol":4,"endCol":38},{"startCol":19,"endCol":37}]},"1218":{"partial":false,"source":"    return function (request, response) {","missing":[{}]},"1219":{"partial":false,"source":"        var remaining = maxRedirects;","missing":[{"startCol":8,"endCol":37},{}]},"1220":{"partial":false,"source":"        var deferred = Q.defer();","missing":[{"startCol":8,"endCol":33},{"startCol":23,"endCol":32},{}]},"1221":{"partial":false,"source":"        var self = this;","missing":[{},{"startCol":8,"endCol":24}]},"1222":{"partial":false,"source":"        var args = arguments;","missing":[{},{"startCol":8,"endCol":29}]},"1223":{"partial":false,"source":"","missing":[{}]},"1224":{"partial":false,"source":"        request = HTTP.normalizeRequest(request);","missing":[{"startCol":8,"endCol":49},{"startCol":18,"endCol":48},{}]},"1225":{"partial":false,"source":"","missing":[{}]},"1226":{"partial":false,"source":"        // try redirect loop","missing":[{}]},"1227":{"partial":false,"source":"        function next() {","missing":[{}]},"1228":{"partial":false,"source":"            Q.fcall(function () {","missing":[{}]},"1229":{"partial":false,"source":"                return app(request, response);","missing":[{},{"startCol":16,"endCol":46},{"startCol":23,"endCol":45}]},"1230":{"partial":false,"source":"            })","missing":[{}]},"1231":{"partial":false,"source":"            .then(function (response) {","missing":[{}]},"1232":{"partial":false,"source":"                if (exports.isRedirect(response)) {","missing":[{"startCol":20,"endCol":48},{}]},"1233":{"partial":false,"source":"                    if (remaining--) {","missing":[{"startCol":24,"endCol":35},{}]},"1234":{"partial":false,"source":"                        request.url = response.headers.location;","missing":[{"startCol":24,"endCol":64},{}]},"1235":{"partial":false,"source":"                        next();","missing":[{},{"startCol":24,"endCol":30}]},"1236":{"partial":false,"source":"                    } else {","missing":[{}]},"1237":{"partial":false,"source":"                        throw new Error(\"Maximum redirects.\");","missing":[{},{"startCol":24,"endCol":62}]},"1238":{"partial":false,"source":"                    }","missing":[{}]},"1239":{"partial":false,"source":"                } else {","missing":[{}]},"1240":{"partial":false,"source":"                    deferred.resolve(response);","missing":[{},{"startCol":20,"endCol":46}]},"1241":{"partial":false,"source":"                }","missing":[{}]},"1242":{"partial":false,"source":"            })","missing":[{}]},"1243":{"partial":false,"source":"            .fail(deferred.reject)","missing":[{}]},"1244":{"partial":false,"source":"        }","missing":[{}]},"1245":{"partial":false,"source":"        next();","missing":[{"startCol":8,"endCol":14},{}]},"1246":{"partial":false,"source":"","missing":[{}]},"1247":{"partial":false,"source":"        return deferred.promise;","missing":[{},{"startCol":8,"endCol":32}]},"1248":{"partial":false,"source":"    };","missing":[{}]},"1252":{"partial":false,"source":"    return isRedirect[response.status] || false;","missing":[{"startCol":4,"endCol":48},{"startCol":11,"endCol":47}]},"1279":{"partial":true,"source":"                        if (cookie.expires && cookie.expires > now) {","missing":[{"startCol":46,"endCol":66}]},"1280":{"partial":false,"source":"                            delete cookie[name];","missing":[{"startCol":28,"endCol":48}]},"1291":{"partial":false,"source":"                        return [];","missing":[{"startCol":24,"endCol":34}]},"1297":{"partial":false,"source":"                                return [];","missing":[{"startCol":32,"endCol":42}]},"1306":{"partial":false,"source":"                                        request.ssl :","missing":[{"startCol":40,"endCol":51}]},"1339":{"partial":false,"source":"                    response.headers[\"set-cookie\"] = [response.headers[\"set-cookie\"]];","missing":[{"startCol":20,"endCol":86}]},"1344":{"partial":false,"source":"                        new Date();","missing":[{"startCol":24,"endCol":34}]},"1347":{"partial":true,"source":"                    if (cookie.host && !hostContains(requestHost, cookie.host))","missing":[{"startCol":40,"endCol":78}]},"1348":{"partial":false,"source":"                        delete cookie.host;","missing":[{"startCol":24,"endCol":43}]},"1372":{"partial":false,"source":"        var parts = content.split(\".\");","missing":[{"startCol":8,"endCol":39},{"startCol":20,"endCol":38}]},"1373":{"partial":false,"source":"        var hosts = [];","missing":[{"startCol":8,"endCol":23}]},"1374":{"partial":false,"source":"        while (parts.length > 1) {","missing":[{"startCol":15,"endCol":31}]},"1375":{"partial":false,"source":"            hosts.push(\".\" + parts.join(\".\"));","missing":[{"startCol":12,"endCol":45},{"startCol":23,"endCol":44},{"startCol":29,"endCol":44}]},"1376":{"partial":false,"source":"            parts.shift();","missing":[{"startCol":12,"endCol":25}]},"1378":{"partial":false,"source":"        return hosts;","missing":[{"startCol":8,"endCol":21}]},"1389":{"partial":false,"source":"        ) || (","missing":[{}]},"1390":{"partial":false,"source":"            container.slice(1) === content","missing":[{},{"startCol":12,"endCol":30}]},"1391":{"partial":false,"source":"        );","missing":[{}]},"1393":{"partial":false,"source":"        return container === content;","missing":[{"startCol":8,"endCol":37},{"startCol":15,"endCol":36}]},"1401":{"partial":false,"source":"        return (","missing":[{}]},"1402":{"partial":false,"source":"            content === container ||","missing":[{"startCol":12,"endCol":33},{}]},"1403":{"partial":false,"source":"            content.indexOf(container + \"/\") === 0","missing":[{"startCol":28,"endCol":43},{},{"startCol":12,"endCol":44}]},"1404":{"partial":false,"source":"        );","missing":[{}]}},"source":"/**\n * Provides tools for making, routing, adapting, and decorating\n * Q-JSGI web applications.\n *\n * Duck Types\n * ----------\n *\n * A Q-JSGI _app_ is a function that accepts a request and returns a\n * response.  The response may be promised.\n *\n * A Q-JSGI _request_ is an object or a promise for an object that has\n * the following properties:\n *\n * * `method` is the HTTP request method as a string.\n * * `path` is a string, guaranteed to start with `\"/\"`.\n * * `headers` is an object mapping lower-case HTTP headers to\n *   their corresponding values as strings.\n * * `body` is a Q-JSGI content body.\n *\n * A Q-JSGI _response_ is an object or a promise for an object that\n * has the following properties:\n *\n * * `status` is the HTTP response status code as a number.\n * * `headers` is an object mapping lower-case HTTP headers to their\n *   corresponding values as strings.\n * * `body` is a Q-JSGI content body.\n *\n * A Q-JSGI response and request content _body_ can be as simple as an\n * array of strings.  It can be a promise.  In general, it must be an\n * object that has a `forEach` method.  The `forEach` method accepts a\n * `write` function.  It goes without saying that `forEach` returns\n * `undefined`, but it can return a promise for `undefined` that will\n * resolve when it has made all of its `write` calls and the request\n * or response can be closed, re-used, or kept alive..  The `forEach`\n * function may call `write` with a `String` any number of times.  The\n * `String` may be promised.\n *\n * @module\n */\n\n/*\n    Multiplexing Routing:\n        Cap\n        Branch\n        Method\n        Accept\n        Language\n    Trial Routing:\n        FirstFound\n    Decorators:\n        Error\n        Log\n        CookieSession TODO reevaluate\n        PathSession TODO reevaluate\n        Limit TODO\n        Cache TODO\n        Time\n        Decorators\n        Tap\n        Trap\n        Permanent\n        Date\n    Adapters:\n        ParseQuery\n        ContentRequest\n        JsonRequest\n        Json\n        Inspect\n    Producers:\n        Content\n        File\n        FileTree\n        Redirect\n        PermanentRedirect\n        TemporaryRedirect\n        RedirectTree\n        PermanentRedirectTree\n        TemporaryRedirectTree\n    Producer Functions:\n        ok\n        badRequest\n        notFound\n        methodNotAllowed\n        notAcceptable\n        file\n        directory\n        redirect\n        json\n    Utility:\n        etag\n\n*/\n\nrequire(\"collections/shim\");\nvar Q = require(\"q\");\nvar NODE_FS = require(\"fs\");\nvar HTTP = require(\"./http\");\nvar FS = require(\"./fs\");\nvar URL = require(\"url\");\nvar MIME_PARSE = require(\"mimeparse\");\nvar MIME_TYPES = require(\"mime\");\nvar URL = require(\"url\");\nvar inspect = require(\"util\").inspect;\nvar QS = require(\"querystring\");\nvar Cookie = require(\"./http-cookie\");\n\n//var UUID = require(\"uuid\");\nvar UUID = {\n    generate: function () {\n        return Math.random().toString(36).slice(2) + Math.random().toString(36).slice(2);\n    }\n};\n\n/**\n * Makes a  Q-JSGI app that only responds when there is nothing left\n * on the path to route.  If the there is unprocessed data on the\n * path, the returned app either forwards to the `notFound` app or\n * returns a `404 Not Found` response.\n *\n * @param {App} app a Q-JSGI application to\n * respond to this end of the routing chain.\n * @param {App} notFound (optional) defaults\n * to the `notFound` app.\n * @returns {App}\n */\nexports.Cap = function (app, notFound) {\n    notFound = notFound || exports.notFound;\n    return function (request, response) {\n        // TODO Distinguish these cases\n        if (request.pathInfo === \"\" || request.pathInfo === \"/\") {\n            return app(request, response);\n        } else {\n            return notFound(request, response);\n        }\n    };\n};\n\n/**\n * Wraps an app with a function that will observe incoming requests\n * before giving the app an opportunity to respond.  If the \"tap\"\n * function returns a response, it will be used in lieu of forwarding\n * the request to the wrapped app.\n */\nexports.Tap = function (app, tap) {\n    return function (request, response) {\n        var self = this, args = arguments;\n        return Q.when(tap.apply(this, arguments), function (response) {\n            if (response) {\n                return response;\n            } else {\n                return app.apply(self, args);\n            }\n        });\n    };\n}\n\n/**\n * Wraps an app with a \"trap\" function that intercepts and may\n * alter or replace the response of the wrapped application.\n */\nexports.Trap = function (app, trap) {\n    return function (request, response) {\n        return Q.when(app.apply(this, arguments), function (response) {\n            if (response) {\n                response.headers = response.headers || {};\n                return trap(response, request) || response;\n            }\n        });\n    };\n}\n\nexports.Date = function (app, present) {\n    present = present || function () {\n        return new Date();\n    };\n    return exports.Trap(app, function (response, request) {\n        response.headers[\"date\"] = \"\" + present();\n    });\n};\n\nvar farFuture =\n    1000 * // ms\n    60 * // s\n    60 * // m\n    24 * // h\n    365 * // d\n    10; // years\nexports.Permanent = function (app, future) {\n    future = future || function () {\n        return new Date(new Date().getTime() + farFuture);\n    };\n    app = exports.Tap(app, function (request, response) {\n        request.permanent = future;\n    });\n    app = exports.Trap(app, function (response, request) {\n        response.headers[\"expires\"] = \"\" + future();\n    });\n    return app;\n};\n\n/**\n * Makes a Q-JSGI app that branches requests based on the next\n * unprocessed path component.\n * @param {Object * App} paths a mapping from path components (single\n * file or directory names) to Q-JSGI applications for subsequent\n * routing.  The mapping may be a plain JavaScript `Object` record,\n * which must own the mapping properties, or an object that has\n * `has(key)` and `get(key)` methods in its prototype chain.\n * @param {App} notFound a Q-JSGI application\n * that handles requests for which the next file name does not exist\n * in paths.\n * @returns {App}\n */\nexports.Branch = function (paths, notFound) {\n    if (!paths)\n        paths = {};\n    if (!notFound)\n        notFound = exports.notFound;\n    return function (request, response) {\n        if (!/^\\//.test(request.pathInfo)) {\n            return notFound(request, response);\n        }\n        var path = request.pathInfo.slice(1);\n        var parts = path.split(\"/\");\n        var part = decodeURIComponent(parts.shift());\n        if (Object.has(paths, part)) {\n            request.scriptName = request.scriptName + part + \"/\";\n            request.pathInfo = path.slice(part.length);\n            return Object.get(paths, part)(request, response);\n        }\n        return notFound(request, response);\n    };\n};\n\n/**\n * Makes an app that returns a response with static content\n * from memory.\n * @param {Body} body a Q-JSGI\n * response body\n * @param {String} contentType\n * @param {Number} status\n * @returns {App} a Q-JSGI app\n */\nexports.Content = function (body, contentType, status) {\n    return function (request, response) {\n        return {\n            \"status\": status || 200,\n            \"headers\": {\n                \"content-type\": contentType || \"text/plain\"\n            },\n            \"body\": body || \"\"\n        };\n    };\n};\n\n/**\n * Returns a Q-JSGI response with the given content.\n * @param {Body} content (optional) defaults to `[\"\"]`\n * @param {String} contentType (optional) defaults to `\"text/plain\"`\n * @param {Number} status (optional) defaults to `200`\n * @returns {Response}\n */\nexports.content =\nexports.ok = function (content, contentType, status) {\n    status = status || 200;\n    content = content || \"\";\n    if (typeof content === \"string\") {\n        content = [content];\n    }\n    contentType = contentType || \"text/plain\";\n    return {\n        \"status\": status,\n        \"headers\": {\n            \"content-type\": contentType\n        },\n        \"body\": content\n    };\n};\n\n/**\n * @param {String} path\n * @param {String} contentType\n * @returns {App}\n */\nexports.File = function (path, contentType) {\n    return function (request, response) {\n        return exports.file(request, String(path), contentType);\n    };\n};\n\n/**\n * @param {String} path\n * @param {{\n       notFound,\n       file,\n       directory,\n       contentType,\n       redirectSymbolicLinks:Boolean,\n       redirect:Function(location),\n       permanent:Boolean\n * }} options\n * @returns {App}\n */\nexports.FileTree = function (root, options) {\n    if (!options)\n        options = {};\n    options.notFound = options.notFound || exports.notFound;\n    options.file = options.file || exports.file;\n    options.directory = options.directory || exports.directory;\n    root = FS.canonical(root);\n    return function (request, response) {\n        var redirect = options.redirect || (\n            request.permanent || options.permanent ?\n            exports.permanentRedirect :\n            exports.temporaryRedirect\n        );\n        return Q.when(root, function (root) {\n            var path = FS.join(root, request.pathInfo.slice(1));\n            return Q.when(FS.canonical(path), function (canonical) {\n                if (!FS.contains(root, canonical))\n                    return options.notFound(request, response);\n                if (path !== canonical && options.redirectSymbolicLinks)\n                    return redirect(request, FS.relativeFromFile(path, canonical));\n                // TODO: relativeFromFile should be designed for URL’s, not generalized paths.\n                return Q.when(FS.stat(canonical), function (stat) {\n                    if (stat.isFile()) {\n                        return options.file(request, canonical, options.contentType);\n                    } else if (stat.isDirectory()) {\n                        return options.directory(request, canonical, options.contentType);\n                    } else {\n                        return options.notFound(request, response);\n                    }\n                });\n            }, function (reason) {\n                return options.notFound(request, response);\n            });\n        });\n    };\n};\n\n/**\n * @param {Request} request\n * @param {String} path\n * @param {String} contentType\n * @returns {Response}\n */\nexports.file = function (request, path, contentType) {\n    // TODO last-modified header\n    contentType = contentType || MIME_TYPES.lookup(path);\n    return Q.when(FS.stat(path), function (stat) {\n        var etag = exports.etag(stat);\n        var range; // undefined or {begin, end}\n        var status = 200;\n        var headers = {\n            \"content-type\": contentType,\n            \"etag\": etag\n        };\n\n        // Partial range requests\n        if (\"range\" in request.headers) {\n            // Invalid cache\n            if (\n                \"if-range\" in request.headers &&\n                etag != request.headers[\"if-range\"]\n            ) {\n                // Normal 200 for entire, altered content\n            } else {\n                // Truncate to the first requested continuous range\n                range = interpretFirstRange(request.headers[\"range\"]);\n                // Like Apache, ignore the range header if it is invalid\n                if (range) {\n                    if (range.end > stat.size)\n                        return exports.responseForStatus(416); // not satisfiable\n                    status = 206; // partial content\n                    headers[\"content-range\"] = (\n                        \"bytes \" +\n                        range.begin + \"-\" + (range.end - 1) +\n                        \"/\" + stat.size\n                    );\n                    headers[\"content-length\"] = \"\" + (range.end - range.begin);\n                }\n            }\n        // Full requests\n        } else {\n            // Cached\n            // We do not use date-based caching\n            // TODO consider if-match?\n            if (etag == request.headers[\"if-none-match\"])\n                return exports.responseForStatus(304);\n            headers[\"content-length\"] = \"\" + stat.size;\n        }\n\n        // TODO sendfile\n        return {\n            \"status\": status,\n            \"headers\": headers,\n            \"body\": FS.open(path, range)\n        };\n    });\n};\n\nvar rangesExpression = /^\\s*bytes\\s*=\\s*(\\d*\\s*-\\s*\\d*\\s*(?:,\\s*\\d*\\s*-\\s*\\d*\\s*)*)$/;\nvar rangeExpression = /^\\s*(\\d*)\\s*-\\s*(\\d*)\\s*$/;\n\nvar interpretRange = function (text, size) {\n    var match = rangeExpression.exec(text);\n    if (!match)\n        return;\n    if (match[1] == \"\" && match[2] == \"\")\n        return;\n    var begin, end;\n    if (match[1] == \"\") {\n        begin = size - match[2];\n        end = size;\n    } else if (match[2] == \"\") {\n        begin = +match[1];\n        end = size;\n    } else {\n        begin = +match[1];\n        end = +match[2] + 1;\n    }\n    return {\n        \"begin\": begin,\n        \"end\": end\n    };\n};\n\nvar interpretFirstRange = exports.interpretFirstRange = function (text, size) {\n    var match = rangesExpression.exec(text);\n    if (!match)\n        return;\n    var texts = match[1].split(/\\s*,\\s*/);\n    var range = interpretRange(texts[0], size);\n    for (var i = 0, ii = texts.length; i < ii; i++) {\n        var next = interpretRange(texts[i], size);\n        if (!next)\n            break;\n        if (next.begin <= range.end) {\n            range.end = next.end;\n        } else {\n            break;\n        }\n    }\n    return range;\n};\n\n/**\n * @param {Stat}\n * @returns {String}\n */\nexports.etag = function (stat) {\n    return [\n        stat.node.ino,\n        stat.size,\n        stat.lastModified().getTime()\n    ].join(\"-\");\n};\n\n/**\n * @param {Request} request\n * @param {String} path\n * @param {Response}\n */\nexports.directory = function (request, path) {\n    return Q.reject(\"directory listing not yet implemented\");\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `301`\n * @returns {App}\n */\nexports.PermanentRedirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.permanentRedirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `301`\n * @returns {App}\n */\nexports.PermanentRedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.permanentRedirect(request, location, status, true);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.TemporaryRedirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.temporaryRedirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.TemporaryRedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.temporaryRedirect(request, location, status, true);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.Redirect = function (location, status, tree) {\n    return function (request, response) {\n        return exports.redirect(request, location, status, tree);\n    };\n};\n\n/**\n * @param {String} path\n * @param {Number} status (optional) default is `307`\n * @returns {App}\n */\nexports.RedirectTree = function (location, status) {\n    return function (request, response) {\n        return exports.redirect(request, location, status, true);\n    };\n};\n\nexports.permanentRedirect = function (request, location, status) {\n    return exports.redirect(request, location, status || 301);\n};\n\nexports.permanentRedirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status || 301, true);\n};\n\nexports.temporaryRedirect = function (request, location, status) {\n    return exports.redirect(request, location, status || 307);\n};\n\nexports.temporaryRedirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status || 307, true);\n};\n\nexports.redirectTree = function (request, location, status) {\n    return exports.redirect(request, location, status, true);\n};\n\n/**\n * @param {String} location\n * @param {Number} status (optional) default is `301`\n * @returns {Response}\n */\nexports.redirect = function (request, location, status, tree) {\n\n    // request.permanent gets set by Permanent middleware\n    status = status || (request.permanent ? 301 : 307);\n\n    // ascertain that the location is absolute, per spec\n    location = URL.resolve(request.url, location);\n\n    // redirect into a subtree with the remaining unrouted\n    // portion of the path, if so configured\n    if (tree) {\n        location = URL.resolve(\n            location,\n            request.pathInfo.replace(/^\\//, \"\")\n        );\n    }\n\n    return {\n        \"status\": status,\n        \"headers\": {\n            \"location\": location,\n            \"content-type\": \"text/html\"\n        },\n        \"body\": [\n            'Go to <a href=\"' + location + '\">' + // TODO escape\n            location +\n            \"</a>\"\n        ]\n    };\n};\n\nexports.Proxy = function (app) {\n    if (typeof app === \"string\") {\n        var location = app;\n        app = function (request) {\n            request.url = location;\n            return request;\n        };\n    }\n    return function (request, response) {\n        return Q.when(app.apply(this, arguments), function (request) {\n            return HTTP.request(request);\n        });\n    };\n};\n\nexports.ProxyTree = function (url) {\n    return exports.Proxy(function (request) {\n        request.url = URL.resolve(url, request.pathInfo.replace(/^\\//, \"\"));\n        return request;\n    });\n};\n\n/// branch on HTTP method\n/**\n * @param {Object * App} methods\n * @param {App} notAllowed (optional)\n * @returns {App}\n */\nexports.Method = function (methods, methodNotAllowed) {\n    var keys = Object.keys(methods);\n    if (!methodNotAllowed)\n        methodNotAllowed = exports.methodNotAllowed;\n    return function (request, response) {\n        var method = request.method;\n        if (Object.has(keys, method)) {\n            return Object.get(methods, method)(request, response);\n        } else {\n            return methodNotAllowed(request, response);\n        }\n    };\n};\n\nvar Negotiator = function (requestHeader, responseHeader, respond) {\n    return function (types, notAcceptable) {\n        var keys = Object.keys(types);\n        if (!notAcceptable)\n            notAcceptable = exports.notAcceptable;\n        return function (request, response) {\n            var header = requestHeader;\n            if (typeof header === \"function\") {\n                header = requestHeader(request);\n            }\n            var accept = request.headers[requestHeader] || \"*\";\n            var type = MIME_PARSE.bestMatch(keys, accept);\n            request.terms = request.terms || {};\n            request.terms[responseHeader] = type;\n            if (Object.has(keys, type)) {\n                return Q.when(types[type](request, response), function (response) {\n                    if (\n                        respond !== null &&\n                        response &&\n                        response.status === 200 &&\n                        response.headers\n                    ) {\n                        response.headers[responseHeader] = type;\n                    }\n                    return response;\n                });\n            } else {\n                return notAcceptable(request, response);\n            }\n        };\n    };\n};\n\n/// branch on HTTP content negotiation\n/**\n * Routes based on content negotiation, between the request's `accept`\n * header and the application's list of possible content types.\n *\n * @param {Object * App} types mapping content types to apps that can\n * handle them.\n * @param {App} notAcceptable\n * @returns {App}\n */\nexports.ContentType = Negotiator(\"accept\", \"content-type\");\nexports.Language = Negotiator(\"accept-language\", \"language\");\nexports.Charset = Negotiator(\"accept-charset\", \"charset\");\nexports.Encoding = Negotiator(\"accept-encoding\", \"encoding\");\nexports.Host = Negotiator(function (request) {\n    return (request.headers.host || \"*\") + \":\" + request.port;\n}, \"host\", null);\n\n// Branch on a selector function based on the request\nexports.Select = function (select) {\n    return function (request, response) {\n        return Q.when(select(request, response), function (app) {\n            return app(request, response);\n        });\n    };\n};\n\n// Create an application from the \"app\" exported by a module\nexports.require = function (id, _require) {\n    _require = _require || require;\n    var async = _require.async || _require;\n    var exports = async(id);\n    return function (request, response) {\n        return Q.when(exports, function (exports) {\n            return exports.app(request, response);\n        });\n    }\n};\n\n/**\n * Decorates a JSGI application such that rejected response promises\n * get translated into `500` server error responses with no content.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Error = function (app, debug) {\n    return function (request, response) {\n        return Q.when(app(request, response), null, function (error) {\n            if (!debug)\n                error = undefined;\n            return exports.responseForStatus(500, error && error.stack || error);\n        });\n    };\n};\n\n/**\n * Decorates a Q-JSGI application such that all requests and responses\n * are logged.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Log = function (app, log, stamp) {\n    log = log || console.log;\n    stamp = stamp || function (message) {\n        return new Date().toISOString() + \" \" + message;\n    };\n    return function (request, response) {\n        var remoteHost =\n            request.remoteHost + \":\" +\n            request.remotePort;\n        var requestLine =\n            request.method + \" \" +\n            request.path + \" \" +\n            \"HTTP/\" + request.version.join(\".\");\n        log(stamp(\n            remoteHost + \" \" +\n            \"-->     \" +\n            requestLine\n        ));\n        return Q.when(app(request, response), function (response) {\n            if (response) {\n                log(stamp(\n                    remoteHost + \" \" +\n                    \"<== \" +\n                    response.status + \" \" +\n                    requestLine + \" \" +\n                    (response.headers[\"content-length\"] || \"-\")\n                ));\n            } else {\n                log(stamp(\n                    remoteHost + \" \" +\n                    \"... \" +\n                    \"... \" +\n                    requestLine + \" (response undefined / presumed streaming)\"\n                ));\n            }\n            return response;\n        }, function (reason) {\n            log(stamp(\n                remoteHost + \" \" +\n                \"!!!     \" +\n                requestLine + \" \" +\n                (reason && reason.message || reason)\n            ));\n            return Q.reject(reason);\n        });\n    };\n};\n\n/**\n * Decorates a Q-JSGI application such that all responses have an\n * X-Response-Time header with the time between the request and the\n * response in milliseconds, not including any time needed to stream\n * the body to the client.\n *\n * @param {App} app\n * @returns {App}\n */\nexports.Time = function (app) {\n    return function (request, response) {\n        var start = new Date();\n        return Q.when(app(request, response), function (response) {\n            var stop = new Date();\n            if (response && response.headers) {\n                response.headers[\"x-response-time\"] = \"\" + (stop - start);\n            }\n            return response;\n        });\n    };\n};\n\n/**\n * Decorates a Q-JSGI application such that all responses have the\n * given additional headers.  These headers do not override the\n * application's given response headers.\n *\n * @param {Object} headers\n * @param {App} app decorated application.\n */\nexports.Headers = function (app, headers) {\n    return function (request, response) {\n        return Q.when(app(request, response), function (response) {\n            if (response && response.headers) {\n                Object.keys(headers).forEach(function (key) {\n                    if (!(key in response.headers)) {\n                        response.headers[key] = headers[key];\n                    }\n                });\n            }\n            return response;\n        });\n    };\n};\n\n/**\n * Wraps a Q-JSGI application in a sequence of decorators.\n * @param {Array * Decorator} decorators\n * @param {App} app\n * @returns {App}\n */\nexports.Decorators = function (decorators, app) {\n    decorators.reversed().forEach(function (Middleware) {\n        app = Middleware(app);\n    });\n    return app;\n};\n\n/**\n * Wraps a Q-JSGI application such that the child application may\n * simply return an object, which will in turn be serialized into a\n * Q-JSGI response.\n *\n * @param {Function(Request):Object} app an application that accepts a\n * request and returns a JSON serializable object.\n * @returns {App}\n */\nexports.Json = function (app, visitor, tabs) {\n    return function (request, response) {\n        return Q.when(app(request, response), function (object) {\n            return exports.json(object, visitor, tabs);\n        });\n    };\n};\n\n/**\n * @param {Object} content data to serialize as JSON\n * @param {Function} visitor\n * @param {Number|String} tabs\n * @returns {Response}\n */\nexports.json = function (content, visitor, tabs) {\n    try {\n        var json = JSON.stringify(content, visitor, tabs);\n    } catch (exception) {\n        return Q.reject(exception);\n    }\n    return exports.ok([json]);\n};\n\n/**\n */\nexports.ParseQuery = function (app) {\n    return function (request, response) {\n        request.query = QS.parse(URL.parse(request.url).query || \"\");\n        return app(request, response);\n    };\n};\n\n/**\n * Wraps an app such that it expects to receive content\n * in the request body and passes that content as a string\n * to as the second argument to the wrapped JSGI app.\n *\n * @param {Function(Request, Object):Response} app\n * @returns {App}\n */\nexports.ContentRequest = function (app) {\n    return function (request, response) {\n        return Q.when(request.body.read(), function (body) {\n            return app(body, request, response);\n        });\n    };\n};\n\n/**\n * @param {Function(Request, Object):Response} app\n * @param {App} badRequest\n * @returns {App}\n */\nexports.JsonRequest = function (app, badRequest) {\n    if (!badRequest)\n        badRequest = exports.badRequest;\n    return exports.ContentRequest(function (content, request, response) {\n        try {\n            var object = JSON.parse(content);\n        } catch (error) {\n            return badRequest(request, error);\n        }\n        return app(object, request, response);\n    });\n};\n\n/**\n * @param {Function(Request):Object}\n * @returns {App}\n */\nexports.Inspect = function (app) {\n    return exports.Method({\"GET\": function (request, response) {\n        return Q.when(app(request, response), function (object) {\n            return {\n                \"status\": 200,\n                \"headers\": {\n                    \"content-type\": \"text/plain\"\n                },\n                \"body\": [inspect(object)]\n            }\n        });\n    }});\n};\n\n/**\n * Creates a persistent session associated with the HTTP client's\n * cookie.  These sessions are intended to persist for the duration\n * that a user visits your site in the same browser.\n *\n * @param {Function(session):App} Session a function that creates a\n * new Q-JSGI application for each new session.\n * @returns {App}\n */\nexports.CookieSession = function (Session) {\n    var sessions = {};\n    function nextUuid() {\n        while (true) {\n            var uuid = UUID.generate();\n            if (!Object.has(sessions, uuid))\n                return uuid;\n        }\n    }\n    return function (request, response) {\n        var cookie = QS.parse(request.headers[\"cookie\"], /[;,]/g);\n        var sessionIds = cookie[\"session.id\"];\n        if (!Array.isArray(sessionIds))\n            sessionIds = [sessionIds];\n        sessionIds = sessionIds.filter(function (sessionId) {\n            return Object.has(sessions, sessionId);\n        });\n        // verifying cookie\n        if (/^\\/~session\\//.test(request.pathInfo)) {\n            if (cookie[\"session.id\"])\n                return exports.TemporaryRedirect(\"../\")(request, response);\n            // TODO more flexible session error page\n            return {\n                \"status\": 404,\n                \"headers\": {\n                    \"content-type\": \"text/plain\"\n                },\n                \"body\": [\n                    \"Access requires cookies\"\n                ]\n            }\n        // session exists\n        } else if (\n            Object.has(cookie, \"session.id\") &&\n            sessionIds.length\n        ) {\n            var session = sessions[sessionIds[0]];\n            session.lastAccess = new Date();\n            request.session = session;\n            return session.route(request, response);\n        // new session\n        } else {\n            var session = {\n                \"id\": nextUuid(),\n                \"lastAccess\": new Date()\n            };\n            sessions[session.id] = session;\n            session.route = Session(session);\n            var response = exports.TemporaryRedirect(request.scriptInfo + \"~session/\")(request, response);\n            response.headers[\"set-cookie\"] = Cookie.stringify(\n                \"session.id\", session.id, {\n                    \"path\": request.scriptInfo\n                }\n            );\n            return response;\n        }\n    };\n};\n\n/**\n * A Q-JSGI application that creates a session associated with a\n * unique path.  These sessions are intended to persist for the\n * duration that a user remains in a single browser window.\n *\n * @param {Function(session):App} a function that creates a new Q-JSGI\n * application for each new session.  It receives an object with the\n * session's `id` and `lastAccess` `Date`.\n * @returns {App}\n */\nexports.PathSession = function (Session) {\n    var sessions = {};\n    function nextUuid() {\n        while (true) {\n            var uuid = UUID.generate();\n            if (!Object.has(sessions, uuid))\n                return uuid;\n        }\n    }\n    return function (request, response) {\n        // TODO request.pathInfo and request.scriptInfo\n        if (request.pathInfo == \"/\") {\n            // new session\n            var session = {\n                \"id\": nextUuid(),\n                \"lastAccess\": new Date()\n            };\n            sessions[session.id] = session;\n            session.route = Session(session);\n            return exports.Json(function (request, response) {\n                return session;\n            })(request, response);\n        } else if (Object.has(sessions, request.pathInfo.slice(1))) {\n            return Object.get(sessions, request.pathInfo.slice(1)).route(request, response);\n        } else {\n            return exports.responseForStatus(404, \"Session does not exist\");\n        }\n    };\n};\n\n/**\n * Returns the response of the first application that returns a\n * non-404 response status.\n *\n * @param {Array * App} apps a cascade of applications to try\n * successively until one of them returns a non-404 status.\n * @returns {App}\n */\nexports.FirstFound = function (cascade) {\n    return function (request, response) {\n        var i = 0, ii = cascade.length;\n        function next() {\n            var response = cascade[i++](request, response);\n            if (i < ii) {\n                return Q.when(response, function (response) {\n                    if (response.status === 404) {\n                        return next();\n                    } else {\n                        return response;\n                    }\n                });\n            } else {\n                return response;\n            }\n        }\n        return next();\n    };\n};\n\n/**\n * {Object * String} a mapping of HTTP status codes to\n * their standard descriptions.\n */\n// Every standard HTTP code mapped to the appropriate message.\n// Stolen from Rack which stole from Mongrel\nexports.HTTP_STATUS_CODES = {\n    100 : 'Continue',\n    101 : 'Switching Protocols',\n    102 : 'Processing',\n    200 : 'OK',\n    201 : 'Created',\n    202 : 'Accepted',\n    203 : 'Non-Authoritative Information',\n    204 : 'No Content',\n    205 : 'Reset Content',\n    206 : 'Partial Content',\n    207 : 'Multi-Status',\n    300 : 'Multiple Choices',\n    301 : 'Moved Permanently',\n    302 : 'Found',\n    303 : 'See Other',\n    304 : 'Not Modified',\n    305 : 'Use Proxy',\n    307 : 'Temporary Redirect',\n    400 : 'Bad Request',\n    401 : 'Unauthorized',\n    402 : 'Payment Required',\n    403 : 'Forbidden',\n    404 : 'Not Found',\n    405 : 'Method Not Allowed',\n    406 : 'Not Acceptable',\n    407 : 'Proxy Authentication Required',\n    408 : 'Request Timeout',\n    409 : 'Conflict',\n    410 : 'Gone',\n    411 : 'Length Required',\n    412 : 'Precondition Failed',\n    413 : 'Request Entity Too Large',\n    414 : 'Request-URI Too Large',\n    415 : 'Unsupported Media Type',\n    416 : 'Request Range Not Satisfiable',\n    417 : 'Expectation Failed',\n    422 : 'Unprocessable Entity',\n    423 : 'Locked',\n    424 : 'Failed Dependency',\n    500 : 'Internal Server Error',\n    501 : 'Not Implemented',\n    502 : 'Bad Gateway',\n    503 : 'Service Unavailable',\n    504 : 'Gateway Timeout',\n    505 : 'HTTP Version Not Supported',\n    507 : 'Insufficient Storage'\n};\n\n/**\n * {Object * Number} a mapping from HTTP status descriptions\n * to HTTP status codes.\n */\nexports.HTTP_STATUS_MESSAGES = {};\nfor (var code in exports.HTTP_STATUS_CODES)\n    exports.HTTP_STATUS_MESSAGES[exports.HTTP_STATUS_CODES[code]] = +code;\n\n/**\n * Determines whether an HTTP response should have a\n * response body, based on its status code.\n * @param {Number} status\n * @returns whether the HTTP response for the given status\n * code has content.\n */\nexports.STATUS_WITH_NO_ENTITY_BODY = function (status) {\n    return (status >= 100 && status <= 199) ||\n        status == 204 || status == 304;\n};\n\n/**\n * @param {Number} status\n * @returns {Function(Request) :Response} a JSGI app that returns\n * a plain text response with the given status code.\n */\nexports.appForStatus = function (status) {\n    return function (request) {\n        return exports.responseForStatus(status, request.method + \" \" + request.path);\n    };\n};\n\n/**\n * @param {Number} status an HTTP status code\n * @param {String} message (optional) a message to include\n * in the response body.\n * @returns a JSGI HTTP response object with the given status\n * code and message as its body, if the status supports\n * a body.\n */\nexports.responseForStatus = function(status, optMessage) {\n    if (exports.HTTP_STATUS_CODES[status] === undefined)\n        throw \"Unknown status code\";\n\n    var message = exports.HTTP_STATUS_CODES[status];\n\n    if (optMessage)\n        message += \": \" + optMessage;\n\n    var content = message + \"\\r\\n\";\n\n    var response = {\n        \"status\": status,\n        \"headers\": {}\n    };\n\n    // RFC 2616, 10.2.5:\n    // The 204 response MUST NOT include a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.3.5:\n    // The 304 response MUST NOT contain a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    if (!exports.STATUS_WITH_NO_ENTITY_BODY(status)) {\n        response.headers['content-length'] = content.length;\n        response.headers['content-type'] = 'text/plain';\n        response.body = [content];\n    }\n\n    return response;\n};\n\n/**\n * {App} an application that returns a 400 response.\n */\nexports.badRequest = exports.appForStatus(400);\n/**\n * {App} an application that returns a 404 response.\n */\nexports.notFound = exports.appForStatus(404);\n/**\n * {App} an application that returns a 405 response.\n */\nexports.methodNotAllowed = exports.appForStatus(405);\n/**\n * {App} an application that returns a 405 response.\n */\nexports.noLanguage =\nexports.notAcceptable = exports.appForStatus(406);\n\nexports.Normalize = function (app) {\n    return function (request, response) {\n        var request = HTTP.normalizeRequest(request);\n        return Q.when(app(request, response), function (response) {\n            return HTTP.normalizeResponse(response);\n        });\n    };\n};\n\nexports.RedirectTrap = function (app, maxRedirects) {\n    maxRedirects = maxRedirects || 20;\n    return function (request, response) {\n        var remaining = maxRedirects;\n        var deferred = Q.defer();\n        var self = this;\n        var args = arguments;\n\n        request = HTTP.normalizeRequest(request);\n\n        // try redirect loop\n        function next() {\n            Q.fcall(function () {\n                return app(request, response);\n            })\n            .then(function (response) {\n                if (exports.isRedirect(response)) {\n                    if (remaining--) {\n                        request.url = response.headers.location;\n                        next();\n                    } else {\n                        throw new Error(\"Maximum redirects.\");\n                    }\n                } else {\n                    deferred.resolve(response);\n                }\n            })\n            .fail(deferred.reject)\n        }\n        next();\n\n        return deferred.promise;\n    };\n};\n\nexports.isRedirect = function (response) {\n    return isRedirect[response.status] || false;\n};\n\nvar isRedirect = {\n    301: true,\n    302: true,\n    303: true,\n    307: true\n};\n\nexports.CookieJar = function (app) {\n    var hostCookies = {}; // to {} of pathCookies to [] of cookies\n    return function (request) {\n\n        var hosts = allHostsContaining(request.headers.host);\n\n        var now = new Date();\n\n        var requestCookies = concat(hosts.map(function (host) {\n\n            // delete expired cookies\n            for (var host in hostCookies) {\n                var pathCookies = hostCookies[host];\n                for (var path in pathCookies) {\n                    var cookies = pathCookies[path];\n                    for (var name in cookies) {\n                        var cookie = cookies[name];\n                        if (cookie.expires && cookie.expires > now) {\n                            delete cookie[name];\n                        }\n                    }\n                }\n            }\n\n            // collect applicable cookies\n            return concat(\n                Object.keys(hostCookies)\n                .map(function (host) {\n                    if (!hostContains(host, request.headers.host))\n                        return [];\n                    var pathCookies = hostCookies[host];\n                    return concat(\n                        Object.keys(pathCookies)\n                        .map(function (path) {\n                            if (!pathContains(path, request.path))\n                                return [];\n                            var cookies = pathCookies[path];\n                            return (\n                                Object.keys(cookies)\n                                .map(function (name) {\n                                    return cookies[name];\n                                })\n                                .filter(function (cookie) {\n                                    return cookie.secure ?\n                                        request.ssl :\n                                        true;\n                                })\n                            );\n                        })\n                    )\n                })\n            );\n\n        }));\n\n        if (requestCookies.length) {\n            request.headers[\"cookie\"] = (\n                requestCookies\n                .map(function (cookie) {\n                    return Cookie.stringify(\n                        cookie.key,\n                        cookie.value,\n                        cookie\n                    );\n                })\n                .join(\"; \")\n            );\n        }\n\n        return Q.when(app.apply(this, arguments), function (response) {\n            response.headers = response.headers || {};\n            if (response.headers[\"set-cookie\"]) {\n                var requestHost = ipRe.test(request.headers.host) ?\n                    request.headers.host :\n                    \".\" + request.headers.host;\n                // normalize to array\n                if (!Array.isArray(response.headers[\"set-cookie\"])) {\n                    response.headers[\"set-cookie\"] = [response.headers[\"set-cookie\"]];\n                }\n                response.headers[\"set-cookie\"].forEach(function (cookie) {\n                    var date = response.headers[\"date\"] ?\n                        new Date(response.headers[\"date\"]) :\n                        new Date();\n                    cookie = Cookie.parse(cookie, date);\n                    // ignore illegal host\n                    if (cookie.host && !hostContains(requestHost, cookie.host))\n                        delete cookie.host;\n                    var host = requestHost || cookie.host;\n                    var path = cookie.path || \"/\";\n                    var pathCookies = hostCookies[host] = hostCookies[host] || {};\n                    var cookies = pathCookies[path] = pathCookies[path] || {};\n                    cookies[cookie.key] = cookie;\n                })\n                delete response.headers[\"set-cookie\"];\n            }\n\n            return response;\n        });\n\n    };\n};\n\nvar ipRe = /^\\d+\\.\\d+\\.\\d+\\.\\d+$/;\n\nfunction allHostsContaining(content) {\n    if (ipRe.test(content)) {\n        return [content];\n    } if (content === \"localhost\") {\n        return [content];\n    } else {\n        var parts = content.split(\".\");\n        var hosts = [];\n        while (parts.length > 1) {\n            hosts.push(\".\" + parts.join(\".\"));\n            parts.shift();\n        }\n        return hosts;\n    }\n}\n\nfunction hostContains(container, content) {\n    if (ipRe.test(container) || ipRe.test(content)) {\n        return container === content;\n    } else if (/^\\./.test(container)) {\n        return (\n            content.lastIndexOf(container) ===\n            content.length - container.length\n        ) || (\n            container.slice(1) === content\n        );\n    } else {\n        return container === content;\n    }\n};\n\nfunction pathContains(container, content) {\n    if (/^\\/$/.test(container)) {\n        return content.indexOf(container) === 0;\n    } else {\n        return (\n            content === container ||\n            content.indexOf(container + \"/\") === 0\n        );\n    }\n}\n\nfunction concat(arrays) {\n    return [].concat.apply([], arrays);\n}","blocks":{"total":239,"seen":68,"missing":171,"percentage":0.28451882845188287}},"hash":"638668d47d0e9c3b5b7bf18c5473c238"},"/Users/kris/q-io/http-cookie.js":{"stats":{"percentage":0.7945205479452054,"lines":[{"lineno":27},{"lineno":29},{"lineno":31},{"lineno":32},{"lineno":33},{"lineno":36},{"lineno":37},{"lineno":38},{"lineno":41},{"lineno":43},{"lineno":62},{"lineno":64},{"lineno":66},{"lineno":68},{"lineno":70}],"missing":15,"seen":58,"total":73,"coverage":{"27":{"partial":false,"source":"            parsed.domain = value;","missing":[{"startCol":12,"endCol":34}]},"29":{"partial":false,"source":"            parsed.path = value;","missing":[{"startCol":12,"endCol":32}]},"31":{"partial":false,"source":"            parsed.expires = new Date(","missing":[{}]},"32":{"partial":false,"source":"                +new Date() + // actual now","missing":[{}]},"33":{"partial":false,"source":"                (new Date(value) - date) // server offset","missing":[{},{"startCol":16,"endCol":40}]},"34":{"partial":false,"source":"            );","missing":[{}]},"36":{"partial":false,"source":"            parsed.expires = new Date(","missing":[{}]},"37":{"partial":false,"source":"                new Date().getTime() +","missing":[{},{"startCol":16,"endCol":36}]},"38":{"partial":false,"source":"                (value * 1000)","missing":[{"startCol":16,"endCol":30},{}]},"39":{"partial":false,"source":"            );","missing":[{}]},"41":{"partial":false,"source":"            parsed.secure = true;","missing":[{"startCol":12,"endCol":33}]},"43":{"partial":false,"source":"            parsed.httpOnly = true;","missing":[{"startCol":12,"endCol":35}]},"62":{"partial":false,"source":"            cookie += \"; Domain=\" + encodeURIComponent(options.domain);","missing":[{"startCol":12,"endCol":71},{"startCol":22,"endCol":70},{"startCol":36,"endCol":70}]},"64":{"partial":false,"source":"            cookie += \"; Path=\" + encodeURIComponent(options.path);","missing":[{"startCol":12,"endCol":67},{"startCol":22,"endCol":66},{"startCol":34,"endCol":66}]},"66":{"partial":false,"source":"            cookie += \"; Expires=\" + options.expires.toGMTString();","missing":[{"startCol":12,"endCol":67},{"startCol":22,"endCol":66},{"startCol":37,"endCol":66}]},"68":{"partial":false,"source":"            cookie += \"; Secure\";","missing":[{"startCol":12,"endCol":33}]},"70":{"partial":false,"source":"            cookie += \"; HttpOnly\";","missing":[{"startCol":12,"endCol":35}]}},"source":"/**\n * Provides utilities for reading and writing HTTP cookies.\n * @module\n */\n\n/*whatsupdoc*/\n\nvar QS = require(\"qs\");\n\n/**\n * @param {String} cookie\n * @returns {Object}\n */\nexports.parse = function (cookie, date) {\n    date = date || new Date();\n    var parsed = {};\n    var terms = cookie.split(/[;,]/g);\n    var keyValue = terms.shift().split(\"=\");\n    parsed.key = keyValue[0];\n    parsed.value = keyValue[1];\n    terms.forEach(function (term) {\n        var parts = term.split(\"=\").map(function (part) {\n            return part.trim();\n        });\n        var key = parts[0], value = parts[1];\n        if (/^domain$/i.test(key)) {\n            parsed.domain = value;\n        } else if (/^path$/i.test(key)) {\n            parsed.path = value;\n        } else if (/^expires$/i.test(key)) {\n            parsed.expires = new Date(\n                +new Date() + // actual now\n                (new Date(value) - date) // server offset\n            );\n        } else if (/^max-age$/i.test(key)) {\n            parsed.expires = new Date(\n                new Date().getTime() +\n                (value * 1000)\n            );\n        } else if (/^secure$/i.test(key)) {\n            parsed.secure = true;\n        } else if (/^httponly$/i.test(key)) {\n            parsed.httpOnly = true;\n        }\n    });\n    return parsed;\n};\n\n/**\n * @param {String} key\n * @param {String} value\n * @param {Object} options (optional)\n * @returns {String} a cookie string\n */\nexports.stringify = function (key, value, options) {\n    var cookie = (\n        encodeURIComponent(key) + \"=\" +\n        encodeURIComponent(value)\n    );\n    if (options) {\n        if (options.domain)\n            cookie += \"; Domain=\" + encodeURIComponent(options.domain);\n        if (options.path)\n            cookie += \"; Path=\" + encodeURIComponent(options.path);\n        if (options.expires)\n            cookie += \"; Expires=\" + options.expires.toGMTString();\n        if (options.secure)\n            cookie += \"; Secure\";\n        if (options.httpOnly)\n            cookie += \"; HttpOnly\";\n    }\n    return cookie;\n};","blocks":{"total":16,"seen":5,"missing":11,"percentage":0.3125}},"hash":"add1cd67243c5d988b19e141c38f2fd9"},"/Users/kris/q-io/spec/http-apps/interpret-range-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":50,"total":50,"coverage":{},"source":"// http://labs.apache.org/webarch/http/draft-fielding-http/p5-range.html#range.units\n\nvar Apps = require(\"../../http-apps\");\n\nvar size = 10000;\nvar tests = [\n    {\n        description: \"The first 500 bytes (byte offsets 0-499, inclusive)\",\n        input: \"bytes=0-499\",\n        oracle: {begin: 0, end: 500}\n    },\n    {\n        description: \"The second 500 bytes (byte offsets 500-999, inclusive)\",\n        input: \"bytes=500-999\",\n        oracle: {begin: 500, end: 1000}\n    },\n    {\n        description: \"The final 500 bytes (byte offsets 9500-9999, inclusive)\",\n        input: \"bytes=-500\",\n        oracle: {begin: 9500, end: 10000}\n    },\n    {\n        description: \"The final 500 bytes (byte offsets 9500-9999, inclusive)\",\n        input: \"bytes=9500-\",\n        oracle: {begin: 9500, end: 10000}\n    },\n    {\n        description: \"The first and last bytes only (bytes 0 and 9999)\",\n        input: \"bytes=0-0,-1\",\n        oracle: {begin: 0, end: 1}\n    },\n    {\n        description: \"Legal but not canonical specification of the second 500 bytes (byte offsets 500-999, inclusive)\",\n        input: \"bytes=500-600,601-999\",\n        oracle: {begin: 500, end: 1000}\n    },\n    {\n        description: \"Legal but not canonical specification of the second 500 bytes (byte offsets 500-999, inclusive)\",\n        input: \"bytes=500-700,601-999\",\n        oracle: {begin: 500, end: 1000}\n    }\n];\n\ndescribe(\"range interpretation\", function () {\n    tests.forEach(function (test) {\n        it(\"should interpret \" + test.input, function () {\n            expect(Apps.interpretFirstRange(test.input, size)).toEqual(test.oracle);\n        });\n    });\n});","blocks":{"total":3,"seen":3,"missing":0,"percentage":1}},"hash":"353abf922edb9ef3ad6663ea5822398b"},"/Users/kris/q-io/spec/http-apps/partial-range-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":30,"total":30,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar Http = require(\"../../http\");\nvar Apps = require(\"../../http-apps\");\nvar FS = require(\"../../fs\");\n\ndescribe(\"http client and server apps\", function () {\n\n    it(\"should read a partial range\", function () {\n        var fixture = FS.join(module.directory || __dirname, \"fixtures\", \"1234.txt\");\n        return Http.Server(Apps.Cap(Apps.File(fixture)))\n        .listen(0)\n        .then(function (server) {\n            var port = server.node.address().port;\n            return Http.read({\n                \"url\": \"http://127.0.0.1:\" + port + \"/\",\n                \"headers\": {\n                    \"range\": \"bytes=1-2\"\n                }\n            }, function (response) {\n                return response.status === 206;\n            })\n            .then(function (content) {\n                expect(content.toString('utf-8')).toEqual('23');\n            })\n            .finally(server.stop)\n        })\n    });\n\n});","blocks":{"total":5,"seen":5,"missing":0,"percentage":1}},"hash":"d7d7ab6eb82b393d03f7dcef122b5001"},"/Users/kris/q-io/spec/http-apps/proxy-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":75,"total":75,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar Http = require(\"../../http\");\nvar Apps = require(\"../../http-apps\");\nvar FS = require(\"../../fs\");\n\ndescribe(\"http proxy\", function () {\n\n    it(\"should work\", function () {\n\n        var requestProxy;\n        var responseProxy;\n        var requestActual;\n        var responseActual;\n\n        var server1 = Http.Server(\n            Apps.Trap(\n                Apps.Tap(\n                    Apps.Branch({\n                        \"foo\": Apps.Branch({\n                            \"bar\": Apps.Cap(Apps.Content([\"Hello, World!\"]))\n                        })\n                    }),\n                    function (request) {\n                        requestActual = request;\n                    }\n                ),\n                function (response) {\n                    responseActual = response;\n                    return response;\n                }\n            )\n        );\n\n        return Q.when(server1.listen(0))\n        .then(function (server1) {\n            var port = server1.node.address().port;\n\n            var server2 = Http.Server(\n                Apps.Trap(\n                    Apps.Tap(\n                        Apps.ProxyTree(\"http://127.0.0.1:\" + port + \"/foo/\"),\n                        function (request) {\n                            requestProxy = request;\n                        }\n                    ),\n                    function (response) {\n                        responseProxy = response;\n                        return response;\n                    }\n                )\n            );\n\n            return [server1, server2.listen(0)];\n        })\n        .spread(function (server1, server2) {\n            var port = server2.node.address().port;\n            return Http.read({\n                url: \"http://127.0.0.1:\" + port + \"/bar\",\n                charset: \"utf-8\"\n            })\n            .then(function (content) {\n                expect(content).toBe(\"Hello, World!\");\n                expect(requestActual).toBeTruthy();\n                expect(responseActual).toBeTruthy();\n                expect(requestProxy).toBeTruthy();\n                expect(responseProxy).toBeTruthy();\n            })\n            .finally(server1.stop)\n            .finally(server2.stop)\n        })\n\n    });\n\n});","blocks":{"total":9,"seen":9,"missing":0,"percentage":1}},"hash":"5700fd2f373b09676b1a324f5b9c6672"},"/Users/kris/q-io/spec/http/basic-spec.js":{"stats":{"percentage":1,"lines":[],"missing":0,"seen":94,"total":94,"coverage":{},"source":"require(\"../lib/jasmine-promise\");\nvar Q = require(\"q\");\nvar HTTP = require(\"../../http\");\n\ndescribe(\"http server and client\", function () {\n\n    it(\"should work as both server and client\", function () {\n        var response = {\n            \"status\": 200,\n            \"headers\": {\n                \"content-type\": \"text/plain\"\n            },\n            \"body\": [\n                \"Hello, World!\"\n            ]\n        };\n\n        var server = HTTP.Server(function () {\n            return response;\n        });\n\n        return server.listen(0)\n        .then(function (server) {\n            var port = server.node.address().port;\n\n            var request = {\n                \"host\": \"localhost\",\n                \"port\": port,\n                \"headers\": {\n                    \"host\": \"localhost\"\n                }\n            };\n\n            return HTTP.request(request)\n            .then(function (response) {\n                expect(Q.isPromise(response.body)).toBe(false);\n                var acc = [];\n                return response.body.read()\n                .then(function (body) {\n                    expect(body.toString(\"utf-8\")).toBe(\"Hello, World!\");\n                });\n            })\n        })\n        .finally(server.stop)\n    });\n\n    it(\"should defer a response\", function () {\n        var response = {\n            \"status\": 200,\n            \"headers\": {\n                \"content-type\": \"text/plain; charset=utf-8\"\n            },\n            \"body\": {\n                \"forEach\": function (write) {\n                    var deferred = Q.defer();\n                    write(\"Hello, World!\");\n                    setTimeout(function () {\n                        deferred.resolve();\n                    }, 100);\n                    return deferred.promise;\n                }\n            }\n        };\n\n        var server = HTTP.Server(function () {\n            return response;\n        });\n\n        return server.listen(0).then(function (server) {\n            var port = server.node.address().port;\n\n            var request = {\n                \"host\": \"localhost\",\n                \"port\": port,\n                \"headers\": {\n                    \"host\": \"localhost\"\n                },\n                \"charset\": \"utf-8\"\n            };\n\n            return HTTP.request(request)\n            .then(function (response) {\n                var acc = [];\n                return response.body.read()\n                .then(function (body) {\n                    expect(body).toBe(\"Hello, World!\");\n                });\n            })\n        })\n        .finally(server.stop)\n    });\n\n\n});","blocks":{"total":13,"seen":13,"missing":0,"percentage":1}},"hash":"bd1492c86cdd9f7e9f5b1cef51b5323f"}}}